unit GenCode;

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, StdCtrls, Spin, ExtCtrls, Menus, ExtDlgs, ComCtrls, ToolWin, ImgList,
  MMSystem, Printers, About, Metro, Kit, RandOpt, Comment, Midi, Buttons, Prefs,
  Sticking, PlayAlong, dxContainer, dxButtons, regware4, dxCore,
  ButtonComps, ShellAPI;

type
  //TAvailChars = 'a'..'z';
  //TAllowedChars = Set of TAvailChars;
  TUpdateType = (Times,Patterns);
  TUpdateSet = Set of TUpdateType;
  TSubDivType = (None, All, Trip, Quint, Sex, Sept, Whole, Half, Quarter, Eight, Sixteen, ThirtyTwo);
  TSubDivSet = Set of TSubDivType;

  TPreferences = Record
        ComplexSubDiv : Boolean;
        PatComments : Boolean;
        AutoPatRep : Boolean;
        ShowHints : Boolean;
        LimbActive : Array[1..4] of Boolean;
        ShiftAdaptAccent : Boolean;
        CountIn : Boolean;
        Counts : Byte;
        RandmDif : Char;
        HighSubDiv : Byte;
        HighSpread : Byte;
        Accents : Boolean;
        HighRhythm : Byte;
        HighAccent : Integer;
        NoteVal : Array[1..6] of Boolean;
  end;

  TPatterns = Record
        AVal : Integer;
        BVal : Integer;
        RHS : String[255];
        LHS : String[255];
        RFS : String[255];
        LFS : String[255];
        RHA : String[255];
        LHA : String[255];
        RFA : String[255];
        LFA : String[255];
        Comment : String[255];
        SNValRH : Real;
        STypeRH : Char;
        SNValLH : Real;
        STypeLH : Char;
        SNValRF : Real;
        STypeRF : Char;
        SNValLF : Real;
        STypeLF : Char;
  end;

  TLimbPat = Record
        RhythmPat : String;
        AccentPat : String;
        SNVal : Real;
        SDiver : Real;
        SType : Char;
        NumSubs : Byte;
        NumSpread : Byte;
        Mute : Boolean;
        Active : Boolean;
  end;

  TVirtualGrid = Record
        NumCells : Integer;
        Cell : Array of Char;
       // GraceNotes : Array of Byte;
        CellWidth : Integer;
        Top : Integer;
        Left : Integer;
        Bottom : Integer;
        MIDIMsg : Array of Integer;
        MIDITime : Array of Integer;
  end;

 {Record for future update
  TVirtualCell = Record
        CellNum : Integer;
        Cell : Char;
        CellType : Word;
        Width : Integer;
        Top : Integer;
        Left : Integer;
        Height : Integer;
        MIDIMsg : Integer;
        MIDITime : Integer;
  end; }

  TMIDIRecord = Record
        Time : Integer;
        Msg : Integer;
  end;

// The following lines of code were generated by the
// Borland Delphi 6 Compiler.
  Tfrmmain = class(TForm)
    saver: TSaveDialog;
    menu: TMainMenu;
    File1: TMenuItem;
    Exit1: TMenuItem;
    opener: TOpenDialog;
    About1: TMenuItem;
    SaveDataFile1: TMenuItem;
    OpenDataFile1: TMenuItem;
    SaveMain1: TMenuItem;
    SaveImageNotation1: TMenuItem;
    pulser: TTimer;
    Functions1: TMenuItem;
    Random1: TMenuItem;
    RandomRhythm1: TMenuItem;
    RandomAccents1: TMenuItem;
    RandomNoteValues1: TMenuItem;
    RandomSubdivision1: TMenuItem;
    ReversePatterns1: TMenuItem;
    tlbarmain: TToolBar;
    popuppat: TPopupMenu;
    ReversePattern1: TMenuItem;
    AllPatterns1: TMenuItem;
    RhythmPatterns1: TMenuItem;
    AccentPatterns1: TMenuItem;
    InversePattern1: TMenuItem;
    RandomPattern1: TMenuItem;
    InversePatterns1: TMenuItem;
    AllPatterns2: TMenuItem;
    RhythmPatterns2: TMenuItem;
    AccentPatterns2: TMenuItem;
    RandomExercise1: TMenuItem;
    imglist: TImageList;
    tbtnopen: TToolButton;
    tbtnsave: TToolButton;
    seperate1: TToolButton;
    shpbar: TShape;
    MetronomeOptions1: TMenuItem;
    Initialiser: TTimer;
    VoicingOptions1: TMenuItem;
    SwapPatten1: TMenuItem;
    RightHand1: TMenuItem;
    LeftHand1: TMenuItem;
    RightFoot1: TMenuItem;
    LeftFoot1: TMenuItem;
    RandomOptions1: TMenuItem;
    Options1: TMenuItem;
    seperate2: TToolButton;
    tbtnmetro: TToolButton;
    popupgrid: TPopupMenu;
    DrawNote1: TMenuItem;
    AccentNote1: TMenuItem;
    MIDIOptions1: TMenuItem;
    imgnotes: TImage;
    nt1: TMenuItem;
    imglistsymbols: TImageList;
    nt2: TMenuItem;
    nt3: TMenuItem;
    nt4: TMenuItem;
    nt5: TMenuItem;
    nt6: TMenuItem;
    nt7: TMenuItem;
    nt8: TMenuItem;
    nt9: TMenuItem;
    nt10: TMenuItem;
    tbtnmidi: TToolButton;
    GeneralPreferences1: TMenuItem;
    StickingPatterns1: TMenuItem;
    SaveAsMIDI1: TMenuItem;
    scrlbarimgnotes: TScrollBar;
    PlayAlongKit1: TMenuItem;
    printdialog: TPrintDialog;
    Print1: TMenuItem;
    Help1: TMenuItem;
    btnhistnext: TdxToolButton;
    btnhistprev: TdxToolButton;
    lblhist: TLabel;
    grphist: TdxContainer;
    tbtnplayalong: TToolButton;
    Tools1: TMenuItem;
    lbltrepository: TLabel;
    lstpatrep: TListBox;
    popuppatrep: TPopupMenu;
    RightHand2: TMenuItem;
    LeftHand2: TMenuItem;
    RightFoot2: TMenuItem;
    LeftFoot2: TMenuItem;
    Rhythm1: TMenuItem;
    Accent1: TMenuItem;
    Rhythm2: TMenuItem;
    Rhythm3: TMenuItem;
    Rhythm4: TMenuItem;
    Accent2: TMenuItem;
    Accent3: TMenuItem;
    Accent4: TMenuItem;
    AddToRepository1: TMenuItem;
    SavePatternRepository1: TMenuItem;
    Open1: TMenuItem;
    OpenPatternRepository1: TMenuItem;
    ApplyPatternTo1: TMenuItem;
    DeletePattern1: TMenuItem;
    regcode: TRegware4;
    imglistrests: TImageList;
    tbnstick: TToolButton;
    Window1: TMenuItem;
    DeviceControls1: TMenuItem;
    Register1: TMenuItem;
    RhythmTrainer1: TMenuItem;
    ReadMe1: TMenuItem;
    grppatopts: TGroupBox;
    lblrhythmpat: TLabel;
    lblaccpat: TLabel;
    btn32: TSpeedButton;
    btnsixteen: TSpeedButton;
    btneight: TSpeedButton;
    btnquarter: TSpeedButton;
    btnhalf: TSpeedButton;
    btnwhole: TSpeedButton;
    lblsubdivs: TLabel;
    lblnotesubdiv: TLabel;
    edtrpat: TEdit;
    edtapat: TEdit;
    pnlmute: TPanel;
    sedtsubdiv: TSpinEdit;
    sedtsubnotes: TSpinEdit;
    grplinkto: TGroupBox;
    rdlinkrh: TRadioButton;
    rdlinklh: TRadioButton;
    rdlinkrf: TRadioButton;
    rdlinklf: TRadioButton;
    tbtnrhythmtrain: TToolButton;
    rdlinknone: TRadioButton;
    scrolltimer: TTimer;
    grpgenopt: TGroupBox;
    lblbars: TLabel;
    sedta: TSpinEdit;
    lblcount: TLabel;
    sedtb: TSpinEdit;
    grpcountmeth: TGroupBox;
    rdcquarter: TRadioButton;
    rdceight: TRadioButton;
    rdcsixteen: TRadioButton;
    lblvgridclr: TLabel;
    clrvgrid: TColorBox;
    Options2: TMenuItem;
    imgcurnote: TImage;
    ApplyVoicing1: TMenuItem;
    popuppat2: TPopupMenu;
    RandomSubdivision2: TMenuItem;
    RandomNoteValue1: TMenuItem;
    statbar: TStatusBar;
    imgtl: TImage;
    imgbl: TImage;
    imgtr: TImage;
    imgbr: TImage;
    udrpat: TUpDown;
    udapat: TUpDown;
    ebtncomment: TEncartaButton;
    abtnclearpatrep: TAOLButton;
    abtnremacc: TAOLButton;
    abtnresnoteval: TAOLButton;
    abtnressub: TAOLButton;
    abtnclear: TAOLButton;
    abtnclearhist: TAOLButton;
    ebtnaccept: TEncartaButton;
    ebtnoptok: TEncartaButton;
    tbtnrand: TToolButton;
    procedure btnclearClick(Sender: TObject);
    procedure Exit1Click(Sender: TObject);
    procedure SaveDataFile1Click(Sender: TObject);
    procedure OpenDataFile1Click(Sender: TObject);
    procedure SaveImageNotation1Click(Sender: TObject);
    procedure btnremaccClick(Sender: TObject);
    procedure About1Click(Sender: TObject);
    procedure btnclearhistClick(Sender: TObject);
    procedure btnressubClick(Sender: TObject);
    procedure btnresnotevalClick(Sender: TObject);
    procedure pulserTimer(Sender: TObject);
    procedure RandomRhythm1Click(Sender: TObject);
    procedure RandomAccents1Click(Sender: TObject);
    procedure RandomNoteValues1Click(Sender: TObject);
    procedure RandomSubdivision1Click(Sender: TObject);
    procedure ReversePattern1Click(Sender: TObject);
    procedure AllPatterns1Click(Sender: TObject);
    procedure RhythmPatterns1Click(Sender: TObject);
    procedure AccentPatterns1Click(Sender: TObject);
    procedure InversePattern1Click(Sender: TObject);
    procedure RandomPattern1Click(Sender: TObject);
    procedure RhythmPatterns2Click(Sender: TObject);
    procedure AccentPatterns2Click(Sender: TObject);
    procedure AllPatterns2Click(Sender: TObject);
    procedure RandomExercise1Click(Sender: TObject);
    procedure sedtaChange(Sender: TObject);
    procedure sedtbChange(Sender: TObject);
    procedure MetronomeOptions1Click(Sender: TObject);
    procedure InitialiserTimer(Sender: TObject);
    procedure VoicingOptions1Click(Sender: TObject);
    procedure RightHand1Click(Sender: TObject);
    procedure LeftHand1Click(Sender: TObject);
    procedure RightFoot1Click(Sender: TObject);
    procedure LeftFoot1Click(Sender: TObject);
    procedure RandomOptions1Click(Sender: TObject);
    procedure imgnotesMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure imgnotesMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure FormMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DrawNote1Click(Sender: TObject);
    procedure AccentNote1Click(Sender: TObject);
    procedure FormClose(Sender: TObject; var Action: TCloseAction);
    procedure MIDIOptions1Click(Sender: TObject);
    procedure nt1Click(Sender: TObject);
    procedure nt2Click(Sender: TObject);
    procedure nt3Click(Sender: TObject);
    procedure nt4Click(Sender: TObject);
    procedure nt5Click(Sender: TObject);
    procedure nt6Click(Sender: TObject);
    procedure nt7Click(Sender: TObject);
    procedure nt8Click(Sender: TObject);
    procedure nt9Click(Sender: TObject);
    procedure nt10Click(Sender: TObject);
    procedure btncommentClick(Sender: TObject);
    procedure GeneralPreferences1Click(Sender: TObject);
    procedure RandomNoteValue1Click(Sender: TObject);
    procedure RandomSubdivision2Click(Sender: TObject);
    procedure StickingPatterns1Click(Sender: TObject);
    procedure SaveAsMIDI1Click(Sender: TObject);
    procedure scrlbarimgnotesChange(Sender: TObject);
    procedure PlayAlongKit1Click(Sender: TObject);
    procedure Print1Click(Sender: TObject);
    procedure btnhistprevClick(Sender: TObject);
    procedure btnhistnextClick(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure btnclearpatrepClick(Sender: TObject);
    procedure AddToRepository1Click(Sender: TObject);
    procedure Rhythm1Click(Sender: TObject);
    procedure Rhythm2Click(Sender: TObject);
    procedure Rhythm3Click(Sender: TObject);
    procedure Rhythm4Click(Sender: TObject);
    procedure Accent1Click(Sender: TObject);
    procedure Accent2Click(Sender: TObject);
    procedure Accent3Click(Sender: TObject);
    procedure Accent4Click(Sender: TObject);
    procedure SavePatternRepository1Click(Sender: TObject);
    procedure OpenPatternRepository1Click(Sender: TObject);
    procedure DeletePattern1Click(Sender: TObject);
    procedure popuppatrepPopup(Sender: TObject);
    procedure EnabledAsParent(container: TWinControl);
    procedure DeviceControls1Click(Sender: TObject);
    procedure Register1Click(Sender: TObject);
    procedure RhythmTrainer1Click(Sender: TObject);
    procedure ReadMe1Click(Sender: TObject);
    procedure btnacceptClick(Sender: TObject);
    procedure pnlmuteClick(Sender: TObject);
    procedure btnquarterClick(Sender: TObject);
    procedure btnhalfClick(Sender: TObject);
    procedure btnwholeClick(Sender: TObject);
    procedure btneightClick(Sender: TObject);
    procedure btnsixteenClick(Sender: TObject);
    procedure btn32Click(Sender: TObject);
    procedure sedtsubdivChange(Sender: TObject);
    procedure sedtsubnotesChange(Sender: TObject);
    procedure edtapatMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure edtrpatMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure rdlinklhClick(Sender: TObject);
    procedure rdlinkrhClick(Sender: TObject);
    procedure rdlinklfClick(Sender: TObject);
    procedure rdlinkrfClick(Sender: TObject);
    procedure rdlinknoneClick(Sender: TObject);
    procedure scrolltimerTimer(Sender: TObject);
    procedure FormDeactivate(Sender: TObject);
    procedure FormActivate(Sender: TObject);
    procedure btnoptokClick(Sender: TObject);
    procedure Options2Click(Sender: TObject);
    procedure ApplyVoicing1Click(Sender: TObject);
    procedure popuppatPopup(Sender: TObject);
    procedure udrpatClick(Sender: TObject; Button: TUDBtnType);
    // End of auto-generated code.

    procedure getpattern(S : String; var newtext : String);
    procedure Randomator(var randtext : String);
    procedure RandomatorA(var randtext : String);
    procedure RandomatorSDiv(Proc : Char; Sel : Integer; ActiveType : TSubDivSet);
    procedure drawnotes(row : integer; DCanvas : TBitmap);
    procedure drawcount(h : integer; DCanvas : TBitmap);
    procedure LoadHistory;
    procedure SaveHistory;
    procedure ErrorCorrector(var errortext : String);
    procedure ErrorCorrectorA(var errortext : String);
    procedure MetroPatternPulse;
    procedure MIDITimeUpdater(Limb : Integer);
    procedure NextEmptyHist;
    procedure DrawGridLines(row : integer; DCanvas : TBitmap);
    procedure UpdatePattern(GridNum : Integer; CellNum : Integer; var REdt : String; var AEdt : String);
    procedure LoadVGrid;
    procedure UpdateEdtBox(ChkRnd : TCheckBox; UpdEdt : TEdit);
    procedure GeneratePattern;
    procedure OnPatternEdtExit(Sender : TObject);
    procedure OnNSBtnClick(Sender : TObject);
    procedure MIDITimeStamp(Old : Array of TMIDIRecord; LOld : Integer; var New : Array of TMIDIRecord);
    procedure CombineAndSort;
    procedure MakeMIDIFile;
    procedure NewCanvasLength;
    procedure PanelUpdate(Sender : TObject; NewCol : TColor);
    procedure Updater(WhatTo : TUpdateSet);
    procedure IntoRepository(ToAdd : String; TypeAdd : Char; WarnMsgs : Boolean);
    procedure FromRepository(ToInsert : String; TypeAdd : Char; IntoWhere : String);
    procedure SwapPattern(OldLimb : Byte; NewLimb : Byte);
    procedure LinkLimbUpdate;
    procedure DrawImageEdges;
    function PatternShift(Pattern : String; Direction : Char) : String;
    function UpdateMetroSliderPos(XPos, YPos : Integer) : Boolean;
    function DetermineCell(XPos, YPos : Integer) : TPoint;
    function ErrorChecker(S : String) : Boolean;
    function ReversePattern(S : String) : String;
    function InvertPatternS(S : String) : String;
    function InvertPatternA(S : String) : String;
    procedure udapatClick(Sender: TObject; Button: TUDBtnType);
    procedure tbtnrandClick(Sender: TObject);

  private
    { Private declarations }
  public
  // Stores which characters are not removed in the ErrorCorrector.
      //AllowedCharsS : TAllowedChars;
      AllowedCharsA : Array[1..10] of Char;
  // The Variables which store the integer commands which will
  // be passed to the MIDIOUTSHORTMSG call.
      MidiMetro : Array[1..3] of Integer;
      MidiCompCmd : Array[1..10,1..2] of Integer;
  // MetroY is the pulse. MetroX is the subdivision of it.
  // MPatCPos is the variable used to store the count position in the pattern.
      metroy, metrosy : real;
      metrox, mpatcpos : byte;
  // The array used to store the different patterns for the History function.
      History : Array[1..10] of TPatterns;
  // Sets storing options.
      InUseSub, InUseNotes : TSubDivSet;
  // Used as bitmap to store the entire pattern.
      ImgPat : TBitmap;
  // Array of VirtualGrids to hold pattern information.
     // VGridV2 : Array[1..4] of Array of TVirtualCell;
      VGrid : Array[1..4] of TVirtualGrid;
  // Array used to store the sorted MIDI info.
      CombinedArray, MIDIArray : Array[1..10000] of TMIDIRecord;
  // Stores which limbs should be modified together.
      LinkedLimbs : Array[1..4] of Byte;
      LinkLimbRd : Array[0..4] of TRadiobutton;
  // The records containing the Limb Pattern Data (Old Method was Groupboxes)
      SelLimb : Byte;
      LimbPat : Array[1..4] of TLimbPat;
  end;

var
  frmmain: Tfrmmain;
// w is used to store how many intervals there are.
  w : integer;
// Stores the Default value for the History function.
  DefaultPattern : TPatterns;
// Used to calculate the Current To Design Screen ratio.
  HRat, WRat : Real;
// Used as a temporary storage bitmap.
  ImgTemp : TBitmap;
// Stores which pattern should be reversed, inverted or randomised.
  EdtSel : TEdit;
  IRType : Char;
// The following variable is used for the metronome part of the application.
  time : real;
// Variables used to "Count".
  Counts, CountPos, BarCount : integer;
// Array holding Metronome Grid information.
  MetroGrid : TVirtualGrid;
// Used lengths of MIDI info arrays.
  HighCombArr, HighMIDIArr : Integer;
// Stores whether or not the VGrids should be drawn.
  VGridDrawn : Boolean;
// Stores the character to be drawn in the VGrid.
  VGridNoteChar : Char;
// Stores all the multi-pattern symbols.
  Symbols : Array[1..10] of TBitmap;
  Rests : Array[1..6] of TBitmap;
// Boolean storing wether or not readme should be viewed at program startup.
  ViewReadMe : Boolean;
// Boolean storing the previous visibilty of the Device Controls.
  DevControlPrevState : Boolean;
  PrevRandBtn : TMenuItem;
  
// **** MIDI VARIABLES ****
// Holds where to start MIDI playback
  StartPos : Byte;
// Handle for the MIDI device.
  hMid : HMIDIOUT;
// Boolean if MIDI is on.
  MIDIOnNow : Boolean;
// Array used to store the timers for MIDI calls.
  MidiTimer : Array[1..4] of Word;

implementation

uses devcntrl, reg, rhythmtrain;

{$R *.dfm}

// THE LIMBS ARE REPRESENTED BY THE FOLLOWING NUMBERS FOR CALCULATIONS
// AND STORAGE WITHIN ARRAY TYPES
// RIGHT HAND = 1;
// LEFT HAND = 2;
// RIGHT FOOT = 3;
// LEFT FOOT = 4;

procedure tfrmmain.EnabledAsParent(container: TWinControl);
var
        index : integer;
        Cntrl : TControl;
        isCntnr : boolean;
begin
        for index := 0 to (container.ControlCount - 1) do
        begin
        Cntrl := container.Controls[index];
        Cntrl.Enabled := container.Enabled;
        isCntnr := (csAcceptsControls in container.Controls[index].ControlStyle);

        if (isCntnr = true) AND (Cntrl is TWinControl) then
        begin
        EnabledAsParent(TWinControl(container.Controls[index]));
        end;
        end;
end;

procedure tfrmmain.drawimageedges;
var
        O1, O2, O3 : TPoint;
        X1, X2, Y1, H1 : Real;
        Ang1, Ang2, Ang3, Ang4, Ang5 : Real;
        Count, c1, c2 : Integer;
        x : Byte;
        FormCol : TColor;
        ImgArr : Array[1..4] of TImage;
begin
        FormCol := frmmain.Color;

        ImgArr[1] := imgtl;
        ImgArr[2] := imgtr;
        ImgArr[3] := imgbr;
        ImgArr[4] := imgbl;

        c1 := 1;
        c2 := 1;

        for x := 1 to 4 do
        begin
        ImgArr[x].canvas.Brush.Color := FormCol;
        ImgArr[x].Canvas.FillRect(Rect(0,0,32,32));
        ImgArr[x].Canvas.pen.Color := clWhite;

        case x of
        1 : begin
                c1 := 1;
                c2 := 90;
                O1 := Point(32,32);
                O2 := Point(0,32);
        end;
        2 : begin
                c1 := 1;
                c2 := 360;
                O1 := Point(0,32);
                O2 := Point(32,32);
        end;
        3 : begin
                c1 := 1;
                c2 := 360;
                O1 := Point(0,0);
                O2 := Point(32,0);
        end;
        4 : begin
                c1 := 271;
                c2 := 360;
                O1 := Point(32,0);
                O2 := Point(0,0);
        end;
        end; // case of

        ImgArr[x].Canvas.PenPos := O1;
        ImgArr[x].Canvas.LineTo(O2.X,O2.Y);

        X1 := O1.X - O2.X;

        For Count := c1 to c2 do
        begin
        Ang1 := Count * Pi / 180;
        Ang2 := (Pi - Ang1) / 2;
        Ang3 := Ang2;

        H1 := Sin(Ang1) * X1 / Sin(Ang2);
        Ang4 := (Pi / 2) - Ang3;
        Ang5 := Pi - (Pi / 2) - Ang4;
        Y1 := Sin(Ang5) * H1 / Sin(Pi / 2);
        X2 := Sin(Ang4) * H1 / Sin(Pi / 2);

        O3 := Point((O2.X + Round(X2)),(O2.Y - Round(Y1)));
        ImgArr[x].Canvas.PenPos := O1;
        ImgArr[x].Canvas.LineTo(O3.X,O3.Y);
        end;
        end;
end;

function tfrmmain.PatternShift(Pattern : String; Direction : Char) : String;
var
        x : integer;
        NewString : String;
begin
        NewString := '';

        if Direction = 'L' then
        begin
                for x := 2 to length(Pattern) do
                        NewString := NewString + Pattern[x];
                NewString := NewString + Pattern[1];
        end;

        if Direction = 'R' then
        begin
                NewString := NewString + Pattern[length(Pattern)];
                for x := 1 to (length(Pattern) - 1) do
                        NewString := NewString + Pattern[x];
        end;

        Result := NewString;
end;

procedure tfrmmain.SwapPattern(OldLimb : Byte; NewLimb : Byte);
var
        Temp : string;
begin
        if IRType = 'S' then
        begin
                Temp := LimbPat[NewLimb].RhythmPat;
                LimbPat[NewLimb].RhythmPat := LimbPat[OldLimb].RhythmPat;
                LimbPat[OldLimb].RhythmPat := Temp;
        end;

        if IRType = 'A' then
        begin
                Temp := LimbPat[NewLimb].AccentPat;
                LimbPat[NewLimb].AccentPat := LimbPat[OldLimb].AccentPat;
                LimbPat[SelLimb].AccentPat := Temp;
        end;
        GeneratePattern;

end;

procedure tfrmmain.FromRepository(ToInsert : String; TypeAdd : Char; IntoWhere : String);
var
        x : Byte;
        TempStr : String;
begin
        TempStr := '';
        if TypeAdd = 'A' then
        for x := 1 to length(ToInsert) do
        begin
                if ToInsert[x] = 'x' then
                TempStr := TempStr + 'X';
                if ToInsert[x] = '-' then
                TempStr := TempStr + 'x';
        end;
        if TypeAdd = 'R' then
        TempStr := ToInsert;
        
        IntoWhere := TempStr;
        updater([Patterns]);
end;

procedure tfrmmain.IntoRepository(ToAdd : String; TypeAdd : Char; WarnMsgs : Boolean);
var
        ShouldAdd : Boolean;
        TempStr : String;
        x : Integer;
begin
        TempStr := '';
        if TypeAdd = 'S' then
        TempStr := ToAdd;

        if TypeAdd = 'A' then
        for x := 1 to length(ToAdd) do
        begin
                if ToAdd[x] = 'X' then
                TempStr := TempStr + 'x';
                if ToAdd[x] = 'x' then
                TempStr := TempStr + '-';
        end;

        ShouldAdd := True;
        if lstpatrep.items.Count <> 0 then
        for x := 0 to (lstpatrep.Items.Count - 1) do
        if TempStr = lstpatrep.Items.Strings[x] then
                begin
                ShouldAdd := False;
                Break;
                end;
        if TempStr = '-' then ShouldAdd := False;

        if ShouldAdd = True then
        lstpatrep.Items.Add(TempStr);

        if ShouldAdd = False then
        if WarnMsgs = True then
        MessageDlg('Pattern either already exists, or is a blank pattern.',mtInformation,[mbOk],0);
end;

procedure tfrmmain.updater(WhatTo : TUpdateSet);
var
        x : Byte;
begin
        if Times in WhatTo then
        begin
        time := frmmetro.edtbpm.value / 60;
        pulser.Interval := round((1000 / time) / metroy); // Pulse
        frmmetro.tmrtest.Interval := pulser.Interval;
        pulser.Interval := round((pulser.interval * 2) / metrox); // Subdivision
        frmmetro.tmrsubdiv.Interval := round(pulser.Interval * metroy / metrosy);
        
        Counts := Trunc(sedtb.value * metroy);// * (metrox / 2));
        frmmetro.lblint.caption := floattostr(pulser.interval) + ' ms.';
        DrawCount(20,ImgPat);
        end;

        if Patterns in WhatTo then
        begin
        ImgPat.Canvas.FillRect(Rect(0,0,imgpat.Width,imgpat.Height));
        w := sedtb.value * sedta.value;
        NewCanvasLength;
        drawcount(20,ImgPat);
        for x := 1 to 4 do
        begin
        ErrorCorrector(LimbPat[x].rhythmpat);
        ErrorCorrectorA(LimbPat[x].accentpat);
        end;
        drawnotes(1,ImgPat);
        drawnotes(2,ImgPat);
        drawnotes(3,ImgPat);
        drawnotes(4,ImgPat);
        imgnotes.Canvas.CopyRect(Rect(0,0,imgnotes.Width,imgnotes.Height),imgpat.Canvas,Rect(scrlbarimgnotes.Position,0,(imgnotes.Width + scrlbarimgnotes.Position),imgnotes.Height));
        LoadVGrid;
        for x := 1 to 4 do
                MidiTimeUpdater(x);
        if ImgPat.Width > ImgNotes.Width then
        begin
        scrlbarimgnotes.Enabled := True;
        scrlbarimgnotes.Max := (MetroGrid.Left + (MetroGrid.CellWidth * MetroGrid.NumCells)) - ImgNotes.Width;
        scrolltimer.Interval := round(((60 / frmmetro.edtbpm.value) * w) / scrlbarimgnotes.Max * 1000);
        end
        else
        begin
        scrlbarimgnotes.Enabled := false;
        scrlbarimgnotes.Position := 0;
        end;
        
        CombineAndSort;
        end;
end;

function tfrmmain.UpdateMetroSliderPos(XPos, YPos : Integer) : Boolean;
var
        GridCellNum, x, PosMIDITime, TotMIDITime, NBarCount : Integer;
begin
        Result := False;
        XPos := XPos + scrlbarimgnotes.Position;
        GridCellNum := 0;
        TotMIDITime := 0;
        NBarCount := 0;

        If (YPos > MetroGrid.Top) AND (YPos < MetroGrid.Bottom) then
        for x := 1 to MetroGrid.NumCells do
        if
        (XPos > (MetroGrid.Left + MetroGrid.CellWidth * (x - 1))) AND
        (XPos < (MetroGrid.Left + MetroGrid.CellWidth * x)) then
        begin
        GridCellNum := x;
        Break;
        end;

        if GridCellNum <> 0 then
        begin
                shpbar.left := MetroGrid.CellWidth * (GridCellNum - 1);
                shpbar.Left := shpbar.left + MetroGrid.Left;
                shpbar.Left := shpbar.Left - scrlbarimgnotes.Position;
                shpbar.Left := shpbar.Left + imgnotes.Left;
                PosMIDITime := GridCellNum * trunc(pulser.Interval); // Cardinal Value truncated to avoid compiler warnings.
                for x := 1 to HighMIDIArr do
                begin
                        TotMIDITime := TotMIDITime + MIDIArray[x].Time;
                        if TotMIDITime >= PosMIDITime then
                        begin
                        StartPos := x;
                        Break;
                        end;
                end;
                if GridCellNum > Counts then
                repeat
                        GridCellNum := GridCellNum - Counts;
                        CountPos := GridCellNum - 1;
                        NBarCount := NBarCount + 1;
                until GridCellNum <= Counts
                else
                CountPos := GridCellNum - 1;
                BarCount := NBarCount;
                Result := True;
        end;
end;

// Used for Mute Panel Buttons.
procedure tfrmmain.PanelUpdate(Sender : TObject; NewCol : TColor);
begin
        if (Sender as TPanel).BevelInner = bvRaised then
        begin
        (Sender as TPanel).BevelInner := bvLowered;
        (Sender as TPanel).BevelOuter := bvLowered;
        (Sender as TPanel).Color := NewCol;
        end
        else
        begin
        (Sender as TPanel).BevelInner := bvRaised;
        (Sender as TPanel).BevelOuter := bvRaised;
        (Sender as TPanel).Color := clBtnFace;
        end;
end;

procedure tfrmmain.MakeMIDIFile;
var
        x : Integer;
        FileSNew : TFileStream;
        BufInt : Integer;
begin
        CombineAndSort;

        FileSNew := TFileStream.Create((saver.FileName),fmCreate);

        BufInt := Ord('M');
        FileSNew.WriteBuffer(BufInt,1);
        BufInt := Ord('T');
        FileSNew.WriteBuffer(BufInt,1);
        BufInt := Ord('h');
        FileSNew.WriteBuffer(BufInt,1);
        BufInt := Ord('d');
        FileSNew.WriteBuffer(BufInt,1);

        BufInt := 0;
        FileSNew.WriteBuffer(BufInt,7);
        BufInt := 6;
        FileSNew.WriteBuffer(BufInt,1);
        BufInt := 0;
        FileSNew.WriteBuffer(BufInt,4);
        BufInt := 0;
        FileSNew.WriteBuffer(BufInt,3);
        BufInt := 1;
        FileSNew.WriteBuffer(BufInt,1);
        BufInt := 5000;
        FileSNew.WriteBuffer(BufInt,4);

        BufInt := Ord('M');
        FileSNew.WriteBuffer(BufInt,1);
        BufInt := Ord('T');
        FileSNew.WriteBuffer(BufInt,1);
        BufInt := Ord('r');
        FileSNew.WriteBuffer(BufInt,1);
        BufInt := Ord('k');
        FileSNew.WriteBuffer(BufInt,1);

        BufInt := High(CombinedArray) * 8;;
        FileSNew.WriteBuffer(BufInt,8);
        BufInt := StrToInt('$000000C9');
        FileSNew.WriteBuffer(BufInt,4);
        for x := 1 to HighMIDIArr do
        begin
                BufInt := StrToInt('$99');
                FileSNew.WriteBuffer(BufInt,4);
                BufInt := MIDIArray[x].Time;
                FileSNew.WriteBuffer(BufInt,4);
                BufInt := MIDIArray[x].Msg;
                FileSNew.WriteBuffer(BufInt,4);
        end;
        FileSNew.Free;
       {
        AssignFile(MIDIFile,saver.FileName);
        Rewrite(MIDIFile);
        Write(MIDIFile,'MThd');
        Write(MIDIFile,chr(00));//6  // 4 bytes, length of header data
        Write(MIDIFile,'0000');  // 2 bytes, track format
        Write(MIDIFile,'0001');  // 2 bytes, num of tracks
        Write(MIDIFile,'5000'); // 2 bytes, division
        Write(MIDIFile,'MTrk');
        Write(MIDIFile,IntToStr(Len)); // 4 bytes, length of track data
        Write(MIDIFile,'000000C9');
        for x := 1 to HighMIDIArr do
        begin
                Write(MIDIFile,IntToStr($99));
                Write(MIDIFile,IntToStr(MIDIArray[x].Time));
                Write(MIDIFile,IntToStr(MIDIArray[x].Msg));
        end;
        CloseFile(MIDIFile);     }
end;

procedure tfrmmain.CombineAndSort;
var
        GNum, LngCell : Byte;
        LngWidth, y, z, x : Integer;
        Temp, LastMsg : TMIDIRecord;
begin
        // COMBINING CODE
        HighCombArr := VGrid[1].NumCells + VGrid[2].NumCells + VGrid[3].NumCells + VGrid[4].NumCells;
        z := 1;
        for GNum := 1 to 4 do
        if LimbPat[GNum].Mute = False then
                for y := 0 to (VGrid[GNum].NumCells - 1) do
                        if VGrid[GNum].MidiMsg[y] <> 0 then
                        begin
                        CombinedArray[z].Msg := VGrid[GNum].MIDIMsg[y];
                        CombinedArray[z].Time := VGrid[GNum].MIDITime[y];
                        z := z + 1;
                        end;

        LastMsg.Msg := 0;
        LngCell := 0;
        LngWidth := 0;
        for GNum := 1 to 4 do
        if VGrid[GNum].CellWidth >= LngWidth then begin LngWidth := VGrid[GNum].CellWidth ; LngCell := GNum; end;

        LastMsg.Time := VGrid[LngCell].MIDITime[(VGrid[LngCell].NumCells - 1)] + MIDITimer[LngCell];

        CombinedArray[z] := LastMsg;
        z := z + 1;
        if z > 0 then
        begin
        HighCombArr := z;

// SORTING CODE : METHOD : SELECTION SORT
        for x := 1 to (HighCombArr - 1) do
                for y := (x+1) to HighCombArr do
                        if CombinedArray[x].Time > CombinedArray[y].Time then
                        begin
                                Temp.Time := CombinedArray[x].Time;
                                Temp.Msg := CombinedArray[x].Msg;
                                CombinedArray[x].Time := CombinedArray[y].Time;
                                CombinedArray[x].Msg := CombinedArray[y].Msg;
                                CombinedArray[y].Time := Temp.Time;
                                CombinedArray[y].Msg := Temp.Msg;
                        end;
        end; // END IF Z > 0

        HighMIDIArr := HighCombArr;
        MIDITimeStamp(CombinedArray,HighCombArr,MIDIArray);
end;

procedure tfrmmain.MIDITimeStamp(Old : Array of TMIDIRecord; LOld : Integer; var New : Array of TMIDIRecord);
var
        x : Integer;
begin
        New[0] := Old[0];
        for x := 1 to LOld do
        begin
                New[x].Msg := Old[x].Msg;
                New[x].Time := Old[x].Time - Old[(x-1)].Time;
        end;
end;

procedure tfrmmain.NewCanvasLength;
var
        HighSDiv, y : real;
begin
        HighSDiv := 1;
        if HighSDiv < LimbPat[1].SDiver then HighSDiv := LimbPat[1].SDiver;
        if HighSDiv < LimbPat[2].SDiver then HighSDiv := LimbPat[2].SDiver;
        if HighSDiv < LimbPat[3].SDiver then HighSDiv := LimbPat[3].SDiver;
        if HighSDiv < LimbPat[4].SDiver then HighSDiv := LimbPat[4].SDiver;

        y := (ImgPat.Width - 50) / (w + 1);
        y := (y / HighSDiv);

        if y <= 30 then
        begin
        ImgPat.Width := ImgPat.Width + (ImgNotes.Width div 2);
        NewCanvasLength;
        end;

        if y >= 160 then
        if (ImgPat.Width - ImgNotes.Width >= ImgNotes.Width) then
        begin
        ImgPat.Width := ImgPat.Width - (ImgNotes.Width div 2);
        NewCanvasLength;
        end;
end;

procedure tfrmmain.RandomatorSDiv(Proc : Char; Sel : Integer; ActiveType : TSubDivSet);
var
        R, MaxNotes : Byte;
        SNVal{, SDiver }: Real;
        SDivCount : Char;
        AllowedSubs : Set of 0..32;
begin
        AllowedSubs := [];
        R := 0;
        MaxNotes := 0;

       // SDiver := LimbPat[Sel].SDiver;
        SNVal := LimbPat[Sel].SNVal;
        SDivCount := LimbPat[Sel].SType;

        if Proc = 'N' then
        begin
                if All in ActiveType then
                        AllowedSubs := [1,2,4,8,16,32];

                if Whole in ActiveType then
                        AllowedSubs := AllowedSubs + [1];

                if Half in ActiveType then
                        AllowedSubs := AllowedSubs + [2];

                if (Quarter in ActiveType) or (None in ActiveType) then
                        AllowedSubs := AllowedSubs + [4];

                if Eight in ActiveType then
                        AllowedSubs := AllowedSubs + [8];

                if Sixteen in ActiveType then
                        AllowedSubs := AllowedSubs + [16];

                if ThirtyTwo in ActiveType then
                        AllowedSubs := AllowedSubs + [32];

                repeat
                R := random(33);
                until R in AllowedSubs;

                SNVal := R / 4;
              //  SDiver := SNVal * (StrToInt(SDivCount) / 2);
        end;

        if Proc = 'S' then
        begin
       { if frmprefs.chkcomplexsubdiv.Checked = false then
                begin
                if All in ActiveType then
                        AllowedSubs := [2,3,5,6,7];

                if Trip in ActiveType then
                        AllowedSubs := AllowedSubs + [3];

                if Quint in ActiveType then
                        AllowedSubs := AllowedSubs + [5];

                if Sex in ActiveType then
                        AllowedSubs := AllowedSubs + [6];

                if Sept in ActiveType then
                        AllowedSubs := AllowedSubs + [7];

                if None in ActiveType then
                        AllowedSubs := AllowedSubs + [2];

                repeat
                R := Random(8);
                until R in AllowedSubs;
                end;     }
       // if frmprefs.chkcomplexsubdiv.Checked = true then
               // begin
                        R := Random(frmrandopt.sedtmaxsubdiv.value) + 1;
               if frmprefs.chkcomplexsubdiv.Checked = true then
                        MaxNotes := Random(frmrandopt.sedtmaxsubnotes.value) + 1;
               // end;
               // SDiver := SNVal * (R / 2);
                SDivCount := IntToStr(R)[1];
        end;

        if Proc = 'N' then
        begin
        LimbPat[Sel].SType := SDivCount;
        LimbPat[Sel].SNVal := SNVal;
       // LimbPat[Sel].SDiver := SDiver;
        end;

        if Proc = 'S' then
        begin
        LimbPat[Sel].SType := SDivCount;
        LimbPat[Sel].SNVal := SNVal;
        LimbPat[Sel].NumSubs := R;
        LimbPat[Sel].NumSpread := MaxNotes;
       // LimbPat[Sel].SDiver := SDiver;
        end;

        LimbPat[Sel].SDiver := LimbPat[Sel].SNVal * (StrToInt(LimbPat[Sel].SType) / LimbPat[Sel].NumSpread);

end;

procedure tfrmmain.OnNSBtnClick(Sender : TObject);
var
        x : byte;
begin
        for x := 1 to 4 do
        LimbPat[x].SDiver := LimbPat[x].SNVal * (StrToInt(LimbPat[x].SType) / LimbPat[x].NumSpread);
        Updater([Patterns]);
end;

procedure tfrmmain.OnPatternEdtExit;
begin
        Updater([Patterns]);
end;

// This procedure used to be the code for btndrawpattern.click.
// It is all the code that needs to be processed to generate the
// patterns and draw them to the screen.
procedure tfrmmain.GeneratePattern;
begin
        frmdevcntrl.btnmidistop.Click;
        w := sedtb.value * sedta.value;;
        imgnotes.Canvas.FillRect(Rect(0,0,imgnotes.width,imgnotes.Height));
        ImgPat.Canvas.FillRect(Rect(0,0,imgpat.width,imgpat.Height));
        Updater([Patterns]);
        VGridDrawn := false;
        SaveHistory;
end;

procedure tfrmmain.UpdateEdtBox(ChkRnd : TCheckBox; UpdEdt : TEdit);
begin
        if ChkRnd.Checked = true then
        UpdEdt.enabled := false;
        if ChkRnd.Checked = false then
        UpdEdt.enabled := true;
end;

procedure tfrmmain.LoadVGrid;
var
        a, x, z, CurCel : integer;
        C, GridNum, aupto, afrom : Byte;
        OldA, OldS : string;
        y, v : real;
begin
        aupto := 1;
        afrom := 1;
        for GridNum := 1 to 4 do
        begin
        OldA := LimbPat[GridNum].AccentPat;
        OldS := LimbPat[GridNum].RhythmPat;
        v := LimbPat[GridNum].SDiver;

        if frmmidi.chkmulti.checked = false then begin afrom := GridNum; aupto := GridNum; end;
        if frmmidi.chkmulti.checked = true then aupto := 10;

        VGrid[GridNum].NumCells := 0;

        y := (ImgPat.Width - 50) / (w + 1);
        z := 100;
        VGrid[GridNum].CellWidth := round(y);
        y := (y / v);
        {
        repeat
        z := z + round(y);
        VGrid[GridNum].NumCells := VGrid[GridNum].NumCells + 1;
        until (z + (round(y) / 2)) >= (ImgPat.Width - 50);
        }

        repeat
        z := z + round(y);
        VGrid[GridNum].NumCells := VGrid[GridNum].NumCells + 1;
        until (z + (round(y) / 2)) >= (MetroGrid.NumCells * MetroGrid.CellWidth + MetroGrid.Left);

        SetLength(VGrid[GridNum].Cell,VGrid[GridNum].NumCells);
        //SetLength(VGrid[GridNum].GraceNotes,VGrid[GridNum].NumCells);
        SetLength(VGrid[GridNum].MIDIMsg,VGrid[GridNum].NumCells);
        SetLength(VGrid[GridNum].MIDITime,VGrid[GridNum].NumCells);

        for x := 0 to (VGrid[GridNum].NumCells - 1) do
        begin
        VGrid[GridNum].Cell[x] := '-';
       // VGrid[GridNum].GraceNotes := nil;
        VGrid[GridNum].MIDIMsg[x] := 0;
        VGrid[GridNum].MIDITime[x] := MIDITimer[GridNum] * x;
        end;

                x := 1;
                CurCel := 0;
                repeat
                        if x > Length(OldS) then x := 1;
                        VGrid[GridNum].Cell[CurCel] := OldS[x];
                        x := x + 1;
                        CurCel := CurCel + 1;
                until CurCel = VGrid[GridNum].NumCells;

                x := 1;
                CurCel := 0;
                repeat
                if x > Length(OldA) then x := 1;
                for C := 1 to 10 do
                if VGrid[GridNum].Cell[CurCel] = AllowedCharsA[C] then
                begin
                        if OldA[x] = 'X' then
                                VGrid[GridNum].Cell[CurCel] := Upcase(AllowedCharsA[C]);
                        x := x + 1;
                        Break;
                end;
                CurCel := CurCel + 1;
                until CurCel = VGrid[GridNum].NumCells;

                for x := 0 to (VGrid[GridNum].NumCells - 1) do
                for a := afrom to aupto do
                begin
                        if VGrid[GridNum].Cell[x] = AllowedCharsA[a] then
                                VGrid[GridNum].MIDIMsg[x] := MidiCompCmd[a,1]
                                else
                        if VGrid[GridNum].Cell[x] = Upcase(AllowedCharsA[a]) then
                                VGrid[GridNum].MIDIMsg[x] := MidiCompCmd[a,2];

                end;
     end; // End GridNum loop
end;

procedure tfrmmain.UpdatePattern(GridNum : Integer; CellNum : Integer; var REdt : String; var AEdt : String);
var
        x, CurC : integer;
        y, yupto : Byte;
        OldS, OldR, NewR, OldA, NewA : String;
begin
        yupto := 1;
        if frmmidi.chkmulti.Checked = false then yupto := 1;
        if frmmidi.chkmulti.Checked = true then yupto := 10;
        OldA := AEdt;
        OldR := REdt;
        OldS := '';
        NewA := '';
        NewR := '';

        CurC := 1;
        for x := 0 to (VGrid[GridNum].NumCells - 1) do
        begin
                OldS := OldS + VGrid[GridNum].Cell[x];

                if OldS[x + 1] <> '-' then
                begin
                NewA := NewA + OldA[CurC];
                CurC := CurC + 1;
                if CurC > Length(OldA) then CurC := 1;
                end;
        end;

        if DrawNote1.Checked = True then
        begin
                if OldS[CellNum] = '-' then
                OldS[CellNum] := VGridNoteChar
                else
                OldS[CellNum] := '-';

        for x := 1 to (VGrid[GridNum].NumCells) do
        for y := 1 to yupto do
        begin
                if (OldS[x] = AllowedCharsA[y]) or (OldS[x] = Upcase(AllowedCharsA[y])) then
                begin
                NewR := NewR + AllowedCharsA[y];
                Break;
                end
                else
                if OldS[x] = '-' then
                begin
                NewR := NewR + '-';
                Break;
                Continue;
                end;
        end;

        if frmprefs.rdbtnaccadapt.Checked = True then
        begin
                if NewR[CellNum] = '-' then
                begin
                        Delete(NewA,CellNum,1);
                        AEdt := NewA;
                        GetPattern(NewA,AEdt);
                end;
                if NewR[CellNum] = 'x' then
                begin
                        Insert('x',NewA,CellNum);
                        AEdt := NewA;
                        GetPattern(NewA,AEdt);
                end;
        end;

                REdt := NewR;
                GetPattern(NewR,REdt);
        end;

        if AccentNote1.Checked = True then
        begin
                CurC := 0;
                if OldS[CellNum] <> '-' then
                begin
                        for x := 1 to CellNum do
                                if OldS[x] <> '-' then CurC := CurC + 1;
                        if (NewA[CurC] = 'x') or (NewA[CurC] = '-') then
                        NewA[CurC] := 'X' else
                        if NewA[CurC] = 'X' then
                        NewA[CurC] := 'x';
                end;
                AEdt := NewA;
                GetPattern(NewA,AEdt);
        end;
end;

function tfrmmain.DetermineCell(XPos, YPos : Integer) : TPoint;
var
        VGridNum, VGridCellNum, x : Integer;
begin
        XPos := XPos + scrlbarimgnotes.Position;
        VGridNum := 0;
        VGridCellNum := 0;
        for x := 1 to 4 do
        If (YPos > VGrid[x].Top) AND (YPos < VGrid[x].Bottom) then
        begin
        VGridNum := x;
        Break;
        end;

        if NOT (VGridNum = 0) then
        for x := 1 to VGrid[VGridNum].NumCells do
        if
        (XPos > (VGrid[VGridNum].Left + VGrid[VGridNum].CellWidth * (x - 1))) AND
        (XPos < (VGrid[VGridNum].Left + VGrid[VGridNum].CellWidth * x)) then
        begin
        VGridCellNum := x;
        Break;
        end;

// Although this function returns a TPoint value, it does NOT
// return a physical co-ordinate. The X Value specifies which
// VGrid to use, and the Y Value which cell.
        Result := Point(VGridNum,VGridCellNum);
end;

// Procedure to draw lines within which notes can be displayed / edited.
procedure tfrmmain.DrawGridLines(row : integer; DCanvas : TBitmap);
var
        h, z, CHeight, CWidth : integer;
        y, v : real;
        ImgPatR, ImgNoteR : TRect;
        CText : String;
begin
        v := LimbPat[row].SDiver;
        CText := LimbPat[row].SType;

        VGrid[row].NumCells := 0;
        CHeight := ImgPat.Height;
        CWidth := ImgPat.Width;
        DCanvas.Width := CWidth;
        DCanvas.Canvas.FillRect(Rect(0,0,DCanvas.width,DCanvas.Height));
        DCanvas.Canvas.Pen.Color := clrvgrid.Selected;
// H is the distance from the top of the Form
// to where the starting point of the drawing should be.
        h := 10 + (row * 75);
        h := Round(h * HRat);

        y := (DCanvas.Width - 50) / (w + 1);
        z := 100;
        y := (y / v);

        VGrid[row].CellWidth := Round(y);
        VGrid[row].Left := z;
        VGrid[row].Top := h - 10;
        VGrid[row].Bottom := h + 10;
        repeat
        DCanvas.Canvas.Rectangle(z,h - 10,z + round(y),h + 10);
        z := z + round(y);
        VGrid[row].NumCells := VGrid[row].NumCells + 1;
        until (z + (round(y) / 2)) >= ((MetroGrid.NumCells * MetroGrid.CellWidth + MetroGrid.Left));

        DCanvas.Canvas.Pen.Color := clBlack;
        DCanvas.Canvas.CopyMode := cmSrcAnd;
        ImgPatR := Rect(scrlbarimgnotes.Position,0,(imgnotes.Width + scrlbarimgnotes.Position),CHeight);
        ImgNoteR := Rect(0,0,imgnotes.Width,imgnotes.Height);
        DCanvas.Canvas.CopyRect(ImgPatR,ImgNotes.Canvas,ImgNoteR);
        DCanvas.Canvas.CopyMode := cmSrcCopy;
        ImgNotes.Canvas.CopyRect(ImgNoteR,DCanvas.Canvas,ImgPatR);
        DCanvas.Canvas.FillRect(Rect(0,0,DCanvas.Width,DCanvas.Height));
end;

// Goes to the next empty history slot.
procedure tfrmmain.NextEmptyHist;
var
        x : Byte;
begin
        for x := 1 to 10 do
        begin
                if (History[x].AVal = DefaultPattern.AVal) then
                if (History[x].BVal = DefaultPattern.BVal) then
                if (History[x].RHS = DefaultPattern.RHS) then
                if (History[x].LHS = DefaultPattern.LHS) then
                if (History[x].RFS = DefaultPattern.RFS) then
                if (History[x].LFS = DefaultPattern.LFS) then
                if (History[x].RHA = DefaultPattern.RHA) then
                if (History[x].LHA = DefaultPattern.LHA) then
                if (History[x].RFA = DefaultPattern.RFA) then
                if (History[x].LFA = DefaultPattern.LFA) then
                begin
                lblhist.caption := IntToStr(x);
                Break;
                end;
        end;
end;

procedure tfrmmain.MIDItimeupdater(Limb : Integer);
var
        NotVal, SubDiv, NotSpace : real;
begin
        SubDiv := StrToInt(LimbPat[Limb].SType);
        NotVal := LimbPat[Limb].SNVal;
        NotSpace := LimbPat[Limb].NumSpread;

        if SubDiv = 1 then SubDiv := 2;
        MidiTimer[Limb] := round((1000 / time) / NotVal);
        MidiTimer[Limb] := round((MidiTimer[Limb] * NotSpace) / SubDiv);
end;

procedure tfrmmain.MetroPatternPulse;
var
        x, lenp : Byte;
        pattern : string;
begin
        pattern := frmmetro.edtmpattern.Text;
        lenp := length(pattern);

        if mpatcpos > lenp then mpatcpos := 1;
        x := mpatcpos;
                if pattern[x] = 'X' then
                midiOutShortMsg(hMid,MidiMetro[1]);
                if pattern[x] = 'x' then
                midiOutShortMsg(hMid,MidiMetro[2]);
        mpatcpos := mpatcpos + 1;
end;

function tfrmmain.InvertPatternS(S : String) : String;
var
        NewS : String;
        x : Byte;
begin
        for x := 1 to length(S) do
        begin
        if (S[x] = '-') then
        NewS := NewS + 'x'
        else
                if (S[x] = 'x') then
                NewS := NewS + '-'
        end;
        Result := NewS;
end;

function tfrmmain.InvertPatternA(S : String) : String;
var
        NewS : String;
        x : Byte;
begin
        for x := 1 to length(S) do
        begin
        if (S[x] = 'X') then
        NewS := NewS + 'x'
        else
                if (S[x] = 'x') then
                NewS := NewS + 'X'
        end;
        Result := NewS;
end;

function tfrmmain.ReversePattern(S : String) : String;
var
        NewS : String;
        x : Byte;
begin
        NewS := '';
        for x := length(S) downto 1 do
        begin
        NewS := NewS + S[x];
        end;
        Result := NewS;
end;

// Corrects most typed errors that can occur for the accents.
procedure tfrmmain.ErrorCorrectorA(var errortext : String);
var
        x, y, yupto : integer;
        Temp : String;
begin
        if Length(errortext) = 0 then errortext := '-';
        yupto := 1;
        if frmmidi.chkmulti.Checked = false then yupto := 1;
        if frmmidi.chkmulti.Checked = true then yupto := 10;

        Temp := errortext;
        for x := 1 to Length(Temp) do
        begin

        for y := 1 to yupto do
                begin
                        if (Temp[x] = Upcase(AllowedCharsA[y])) then Temp[x] := 'X';
                        if (Temp[x] = AllowedCharsA[y]) then Temp[x] := 'x';
                end;

        if (Temp[x] <> 'x') AND (Temp[x] <> 'X') AND (Temp[x] <> '-') then
                Temp[x] := 'x';
        end;
        if ErrorChecker(Temp) = true then Temp := '-';
        errortext := Temp;
end;

// Corrects most typed errors that can occur for the rhythms.
procedure tfrmmain.ErrorCorrector(var errortext : String);
var
        x, y, z, yupto : integer;
        Temp : String;
        Checked, CFound : Boolean;
begin
        if length(errortext) = 0 then errortext := '-';
       // yupto := 1;
        if frmmidi.chkmulti.Checked = false then yupto := 1 else yupto := 10;

                Temp := errortext;
                for x := 1 to Length(Temp) do
                begin
                        for y := 1 to yupto do
                        begin
                                Checked := False;
                                if (Temp[x] = Upcase(AllowedCharsA[y])) OR (Temp[x] = AllowedCharsA[y]) then
                                begin
                                if (Temp[x] = Upcase(AllowedCharsA[y])) then Temp[x] := AllowedCharsA[y];
                                Checked := True;
                                end;
                                if Checked = True then Break;
                        end;

                CFound := True;
                for z := 1 to yupto do
                if Temp[x] <> AllowedCharsA[z] then
                        begin
                        CFound := False;
                        Continue;
                        end
                else
                        begin
                        CFound := True;
                        Break;
                        end;
                if (CFound = False) {and (Temp[x] <> '.')} and (Temp[x] <> '-') then Temp[x] := '-';
                end; // end for x loop
                
                for x := Length(Temp) downto 1 do
                if x < Length(Temp) then
                        //if (Temp[x] = '.') AND (Temp[x+1] = '-') then Delete(Temp,x,1);
                //if (Temp[1] = '-') AND (Temp[Length(Temp)] = '.') then Delete(Temp,Length(Temp),1);
                //if (Temp[1] = '.') AND (Temp[Length(Temp)] = '.') then Delete(Temp,Length(Temp),1);
                if ErrorChecker(Temp) = true then Temp := '-';
                errortext := Temp;
end;

// Checks to see if the pattern consists only of
// grace notes and/or blanks.
function tfrmmain.ErrorChecker(S : String) : Boolean;
var
        x : Byte;
        Error : Boolean;
begin
        Error := True;
        for x := 1 to Length(S) do
        begin
        if {(S[x] <> '.') AND }(S[x] <> '-') then
                begin
                Error := False;
                Break;
                end;
        end;
        Result := Error;
end;

// Saves the History.
procedure tfrmmain.SaveHistory;
var
        HistVal : Byte;
begin
        HistVal := StrToInt(lblhist.caption);
        History[HistVal].AVal := sedta.Value;
        History[HistVal].BVal := sedtb.Value;
        History[HistVal].RHS := LimbPat[1].RhythmPat;
        History[HistVal].LHS := LimbPat[2].RhythmPat;
        History[HistVal].RFS := LimbPat[3].RhythmPat;
        History[HistVal].LFS := LimbPat[4].RhythmPat;
        History[HistVal].RHA := LimbPat[1].AccentPat;
        History[HistVal].LHA := LimbPat[2].AccentPat;
        History[HistVal].RFA := LimbPat[3].AccentPat;
        History[HistVal].LFA := LimbPat[4].AccentPat;
        History[HistVal].STypeRH := LimbPat[1].SType;
        History[HistVal].STypeLH := LimbPat[2].SType;
        History[HistVal].STypeRF := LimbPat[3].SType;
        History[HistVal].STypeLF := LimbPat[4].SType;
        History[HistVal].SNValRH := LimbPat[1].SNVal;
        History[HistVal].SNValLH := LimbPat[2].SNVal;
        History[HistVal].SNValRF := LimbPat[3].SNVal;
        History[HistVal].SNValLF := LimbPat[4].SNVal;
end;

// Loads the History.
procedure tfrmmain.LoadHistory;
var
        HistVal, x : Byte;
begin
        HistVal := StrToInt(lblhist.caption);
        sedta.Value := History[HistVal].AVal;
        sedtb.Value := History[HistVal].BVal;
        LimbPat[1].RhythmPat := History[HistVal].RHS;
        LimbPat[2].RhythmPat := History[HistVal].LHS;
        LimbPat[3].RhythmPat := History[HistVal].RFS;
        LimbPat[4].RhythmPat := History[HistVal].LFS;
        LimbPat[1].AccentPat := History[HistVal].RHA;
        LimbPat[2].AccentPat := History[HistVal].LHA;
        LimbPat[3].AccentPat := History[HistVal].RFA;
        LimbPat[4].AccentPat := History[HistVal].LFA;

        LimbPat[1].SType := History[HistVal].STypeRH;
        LimbPat[2].SType := History[HistVal].STypeLH;
        LimbPat[3].SType := History[HistVal].STypeRF;
        LimbPat[4].SType := History[HistVal].STypeLF;
        LimbPat[1].SNVal := History[HistVal].SNValRH;
        LimbPat[2].SNVal := History[HistVal].SNValLH;
        LimbPat[3].SNVal := History[HistVal].SNValRF;
        LimbPat[4].SNVal := History[HistVal].SNValLF;

        for x := 1 to 4 do
        LimbPat[x].SDiver := LimbPat[x].SNVal * (StrToInt(LimbPat[x].SType) / LimbPat[x].NumSpread);

     //   if NOT (History[HistVal].Comment = '') then
        if frmprefs.chkdispcomment.Checked  = true then frmcomment.Show;
end;

// Procedure to draw the count on the specified canvas.
procedure tfrmmain.drawcount(h : integer; DCanvas : TBitmap);
var
        x, z, maxval, countval, cur : integer;
        y, v : real;
begin
        maxval := sedtb.value;
        h := Round(h * HRat) - 10;

        y := (DCanvas.Width - 50) / (w + 1);
        z := 100;
        countval := 1;

        v := metroy * (metrox / 2);
        y := (y / v);

        MetroGrid.CellWidth := Round(y);
        MetroGrid.Left := z;
        MetroGrid.Top := h - 10;
        MetroGrid.Bottom := h + 10;
        MetroGrid.NumCells := round(w * (metrox / 2) * metroy);
        
        y := (y * v);

        for x := 1 to w do
        begin
                if countval = 1 then
                begin
                        DCanvas.Canvas.Font.Style := [fsBold];
                        DCanvas.Canvas.Font.Size := 10;
                end
                else
                begin
                        DCanvas.Canvas.Font.Style := [];
                        DCanvas.Canvas.Font.Size := 8;
                end;
                DCanvas.Canvas.TextOut(z,h,inttostr(countval));
                z := z + round(y);
                countval := countval + 1;
                if countval > maxval then countval := 1;
        end;
        DCanvas.Canvas.Font.Style := [];
        DCanvas.Canvas.Font.Size := 8;

        if (rdceight.Checked = true) or (rdcsixteen.Checked = true) then
        begin
        z := 100;
        z := z + (round(y) div 2);
        countval := 1;
        for x := 1 to w do
        begin
                DCanvas.Canvas.TextOut(z,h,'+');
                z := z + round(y);
                countval := countval + 1;
                if countval > maxval then countval := 1;
        end;
        end;

        if rdcsixteen.Checked = true then
        begin
        cur := 1;
        z := 100;
        z := z + (round(y) div 4);
        countval := 1;
        for x := 1 to (w * 2) do
        begin
                if cur = 1 then
                begin
                DCanvas.Canvas.TextOut(z,h,'e');
                cur := 2;
                end else if cur = 2 then
                begin
                DCanvas.Canvas.TextOut(z,h,'a');
                cur := 1;
                end;
                z := z + (round(y) div 2);
                countval := countval + 1;
                if countval > maxval then countval := 1;
        end;
        end;

        if frmprefs.chkrhact.Checked = true then
        DCanvas.Canvas.TextOut(3,Round(60 * HRat),'Right Hand');
        if frmprefs.chklhact.Checked = true then
        DCanvas.Canvas.TextOut(3,Round(135 * HRat),'Left Hand');
        if frmprefs.chkrfact.Checked = true then
        DCanvas.Canvas.TextOut(3,Round(210 * HRat),'Right Foot');
        if frmprefs.chklfact.Checked = true then
        DCanvas.Canvas.TextOut(3,Round(285 * HRat),'Left Foot');
end;

// Procedure to draw the patterns on the specified canvas.
procedure tfrmmain.drawnotes(row : integer; DCanvas : TBitmap);
var
        i, f, x, xupto, xs, xa, slens, slena, s, h, z, SubNotes, CurCell : integer;
        resttype : byte;
        y, v : real;
        edtstext, edtatext, CText : string;
        chkact : Boolean;
begin
// i and f are the initial and final values respectivly,
// used to determine the size of each note.
        i := 0;
        f := 10;
        edtstext := '';
        edtatext := '';

        CurCell := 1;

        v := LimbPat[row].SDiver;
        CText := LimbPat[row].SType;
        edtstext := LimbPat[row].rhythmpat;
        edtatext := LimbPat[row].accentpat;
        chkact := LimbPat[row].active;
        SubNotes := LimbPat[row].NumSpread;
        resttype := trunc(LimbPat[row].SNVal * 4);

        slens := length(edtstext);
        slena := length(edtatext);

        if chkact = true then
        begin
// H is the distance from the top of the Form
// to where the starting point of the drawing should be.
        h := 10 + (row * 75);
        h := Round(h * HRat);

        DCanvas.Canvas.Rectangle(20,h,(DCanvas.Width - 20),h+1);
        DCanvas.Canvas.Rectangle(20,h-10,21,h+10);
        DCanvas.Canvas.Rectangle((DCanvas.Width - 21),h-10,(DCanvas.Width - 20),h+10);

        y := (DCanvas.Width - 50) / (w + 1);
        z := 100;
        y := (y / v);
        xs := 1;
        xa := 0;

        xupto := 1;
        if frmmidi.chkmulti.Checked = false then xupto := 1;
        if frmmidi.chkmulti.Checked = true then xupto := 10;

        if slens >= 1 then
        repeat
                if xs > slens then xs := 1;
                for x := 1 to xupto do
                begin
                        // Draws a normal note.
                        if edtstext[xs] = AllowedCharsA[x] then
                                begin
                                DCanvas.Canvas.CopyRect(Rect(i+z-1,h-6,f+z+1,h+6),Symbols[x].Canvas,Rect(0,0,16,16));
                                xa := xa + 1;
                                end;

                        if (slena > 0) and NOT(xa = 0) then
                        begin
                                if xa > slena then xa := 1;
                                // Draws an accented note.
                                if (edtatext[xa] = 'X') and (edtstext[xs] = AllowedCharsA[x]) then
                                        begin
                                        DCanvas.Canvas.Font.Size := 11;
                                        DCanvas.Canvas.TextOut(i+z+5,h-42,'>');
                                        DCanvas.Canvas.Font.Size := 8;
                                        end;
                        end;

            {
                // Draws a grace note.
                if edtstext[xs] = '.' then
                begin
                        begin
                        h := 10 + (LinkedLimbs[row] * 75);
                        h := Round(h * HRat);
                        end;
                        DCanvas.Canvas.Ellipse(i+z-4,h-5,f+z-8,h+2);
                        if NOT((xs+1) > slens) then
                                if edtstext[xs+1] = '.' then
                                begin
                                        DCanvas.Canvas.Ellipse(i+z-8,h-5,f+z-12,h+2);
                                        if NOT((xs+2) > slens) then
                                        if edtstext[xs+2] = '.' then DCanvas.Canvas.Ellipse(i+z-12,h-5,f+z-16,h+2);
                                end;

                        z := z - Round(y);
                        h := 10 + (row * 75);
                        h := Round(h * HRat);
                end;                       }
                
                        // Draws the notes beam.
                        case resttype of
                        (4) : if (edtstext[xs] <> '-') {and (edtstext[xs] <> '.')} then
                                DCanvas.Canvas.Rectangle(f+z,h-25,f+z+2,h);

                        (8) : if (edtstext[xs] <> '-') {and (edtstext[xs] <> '.')} then
                                begin
                                DCanvas.Canvas.Rectangle(f+z,h-25,f+z+2,h);
                                if (CurCell mod LimbPat[row].NumSubs) <> 0 then
                                if (xs+1 <= length(edtstext)) then if (edtstext[xs+1] <> '-') then
                                        DCanvas.Canvas.Rectangle(f+z,h-25,f+z+round(y),h-23);
                                if (xs-1 > 0) then if (edtstext[xs-1] = '-') then
                                        DCanvas.Canvas.Rectangle(f+z,h-25,f+z+10,h-23);
                                end;

                        (16) : if (edtstext[xs] <> '-') {and (edtstext[xs] <> '.')} then
                                begin
                                DCanvas.Canvas.Rectangle(f+z,h-25,f+z+2,h);
                                if (CurCell mod LimbPat[row].NumSubs) <> 0 then
                                if (xs+1 <= length(edtstext)) then if (edtstext[xs+1] <> '-') then
                                begin
                                        DCanvas.Canvas.Rectangle(f+z,h-25,f+z+round(y),h-23);
                                        DCanvas.Canvas.Rectangle(f+z,h-20,f+z+round(y),h-18);
                                end;
                                if (xs-1 > 0) then if (edtstext[xs-1] = '-') then
                                begin
                                        DCanvas.Canvas.Rectangle(f+z,h-25,f+z+10,h-23);
                                        DCanvas.Canvas.Rectangle(f+z,h-20,f+z+10,h-18);
                                end;
                                end;
                                
                        (32) : if (edtstext[xs] <> '-') {and (edtstext[xs] <> '.')} then
                                begin
                                DCanvas.Canvas.Rectangle(f+z,h-25,f+z+2,h);
                                if (CurCell mod LimbPat[row].NumSubs) <> 0 then
                                if (xs+1 <= length(edtstext)) then if (edtstext[xs+1] <> '-') then
                                begin
                                        DCanvas.Canvas.Rectangle(f+z,h-25,f+z+round(y),h-23);
                                        DCanvas.Canvas.Rectangle(f+z,h-20,f+z+round(y),h-18);
                                        DCanvas.Canvas.Rectangle(f+z,h-15,f+z+round(y),h-13);
                                end;
                                if (xs-1 > 0) then if (edtstext[xs-1] = '-') then
                                begin
                                        DCanvas.Canvas.Rectangle(f+z,h-25,f+z+10,h-23);
                                        DCanvas.Canvas.Rectangle(f+z,h-20,f+z+10,h-18);
                                        DCanvas.Canvas.Rectangle(f+z,h-15,f+z+10,h-13);
                                end;
                                end;
                        end;
                        CurCell := CurCell + 1;

                        // Draws the rest notes.
                        case resttype of
                        (1) : if edtstext[xs] = '-' then
                                DCanvas.Canvas.CopyRect(Rect(i+z-1,h-6,f+z+1,h+6),Rests[1].Canvas,Rect(0,0,16,16));
                        (2) : if edtstext[xs] = '-' then
                                DCanvas.Canvas.CopyRect(Rect(i+z-1,h-6,f+z+1,h+6),Rests[2].Canvas,Rect(0,0,16,16));
                        (4) : if edtstext[xs] = '-' then
                                DCanvas.Canvas.CopyRect(Rect(i+z-1,h-6,f+z+1,h+6),Rests[3].Canvas,Rect(0,0,16,16));
                        (8) : if edtstext[xs] = '-' then
                                DCanvas.Canvas.CopyRect(Rect(i+z-1,h-6,f+z+1,h+6),Rests[4].Canvas,Rect(0,0,16,16));
                        (16) : if edtstext[xs] = '-' then
                                DCanvas.Canvas.CopyRect(Rect(i+z-1,h-6,f+z+1,h+6),Rests[5].Canvas,Rect(0,0,16,16));
                        (32) : if edtstext[xs] = '-' then
                                DCanvas.Canvas.CopyRect(Rect(i+z-1,h-6,f+z+1,h+6),Rests[6].Canvas,Rect(0,0,16,16));
                        end;

                end; // End For 1 to xupto

                z := z + round(y);
                xs := xs + 1;
                until (z + (round(y) / 2)) >= ((MetroGrid.NumCells * MetroGrid.CellWidth + MetroGrid.Left));

                s := 1;
                y := (DCanvas.Width - 50) / (w + 1);
                z := 100;
                y := (y / v);

        if NOT (edtstext = '-') then        
        if NOT (strtoint(CText) = 2) then
        begin
                repeat
                // Code for generating the subdivision count
                if (s = 1) or (s = strtoint(CText)) then
                DCanvas.Canvas.TextOut(i+z,h-55,'|');

                // Draws the subdivision note values.
                if s = Round(StrToFloat(CText) / 2) then
                DCanvas.Canvas.TextOut(i+z,h-55,(CText + '/' + IntToStr(SubNotes)));

                s := s + 1;
                if s > strtoint(CText) then s := 1;

                z := z + round(y)
                until (z + (round(y) / 2)) >= ((MetroGrid.NumCells * MetroGrid.CellWidth + MetroGrid.Left));
        end;
        end; // End for if chkact.enabled = true
end;

// This procedure takes the entire rhythm, and tries to retrieve
// a single pattern from it. This makes it easier for the user
// to see what is being played.
procedure Tfrmmain.getpattern(S : String; var newtext : String);
var
        x, y, z : integer;
        Verified : Boolean;
        Test1 : String;
begin
        Test1 := '';
        Verified := False;

        for x := 1 to length(S) do
        begin

                for y := 1 to x  do
                Test1 := Test1 + S[y];

        // For every character in the pattern being tested for,
        // it is compared to its equal in the actual pattern to
        // see wether or not a simplified pattern has been found.
                y := 1;
                for z := 1 to length(S) do
                        begin
                        if y = (length(Test1) + 1) then y := 1;
                                if NOT (Test1[y] = S[z]) then
                                begin
                                newtext := S;
                                Verified := False;
                                Test1 := '';
                                Break;
                                end
                                else
                                Verified := True;

                        y := y + 1;
                        end;
                if Verified = True then Break;        
                end;

        if  (Verified = True) then newtext := Test1;
end;

// The procedure to generate a random rhythm pattern.
procedure Tfrmmain.Randomator(var randtext : String);
var
        counter, x : Byte;
        Rndm : String;
begin
        Rndm := '';
        counter := Random(frmrandopt.sedtmaxpatlength.value + 1);
        while not (counter > 1) do counter := Random(frmrandopt.sedtmaxpatlength.value + 1);
        for x := 1 to counter do
                if Random(2) = 0 then
                Rndm := Rndm + 'x' else
                Rndm := Rndm + '-';
        randtext := Rndm;
        Getpattern(Rndm,randtext);
        if frmprefs.chkautoaddpatrep.Checked = true then
        IntoRepository(randtext,'S',False);
end;

// The procedure to generate a random accent pattern.
procedure Tfrmmain.RandomatorA(var randtext : String);
var
        counter, x : Byte;
        Rndm : String;
begin
        Rndm := '';
        counter := Random(frmrandopt.sedtmaxacclength.value + 1);
        while not (counter > 1) do counter := Random(frmrandopt.sedtmaxacclength.value + 1);
        for x := 1 to counter do
                if Random(2) = 0 then
                Rndm := Rndm + 'X' else
                Rndm := Rndm + 'x';
        randtext := Rndm;
        Getpattern(Rndm,randtext);
        if frmprefs.chkautoaddpatrep.Checked = true then
        IntoRepository(randtext,'A',False);
end;

// Clears everything on the form and resets all
// the settings that can be changed to their
// default values.
procedure Tfrmmain.btnclearClick(Sender: TObject);
var
        x : byte;
begin
        if MessageDlg('This will clear the current pattern data. Do you wish to continue?',mtWarning,[mbYes,mbNo],0)
        = mrYes then
        begin
        imgnotes.Canvas.FillRect(Rect(0,0,imgnotes.Width,imgnotes.Height));
        imgpat.Width := imgnotes.Width;

        for x := 1 to 4 do
        begin
        LimbPat[x].NumSubs := 2;
        LimbPat[x].NumSpread := 2;
        LimbPat[x].RhythmPat := '-';
        LimbPat[x].AccentPat := '-';
        LimbPat[x].SNVal := 1;
        LimbPat[x].SType := '2';
        LimbPat[x].SDiver := LimbPat[x].SNVal * (StrToInt(LimbPat[x].SType) / LimbPat[x].NumSpread);
        end;

        sedta.Value := 1;
        sedtb.Value := 4;

        abtnressub.OnClick(Sender);
        abtnresnoteval.OnClick(Sender);
        GeneratePattern;
        end;
end;

// Exits the application
procedure Tfrmmain.Exit1Click(Sender: TObject);
begin
        Application.Terminate;
end;

// Displays the 'About' form.
procedure Tfrmmain.About1Click(Sender: TObject);
begin
        Frmabout.Visible := true;
        Frmabout.BringToFront;
        frmmain.Enabled := false;
end;

// Saves a file containing Pattern Data.
procedure Tfrmmain.SaveDataFile1Click(Sender: TObject);
var
        x : Byte;
        DatFile : File of TPatterns;
begin
        saver.DefaultExt := 'gdh';
        saver.Filter := 'DrumGen Data (.gdh)|*.gdh';
        saver.FileName := 'Untitled Exercise';
        saver.execute;

        if NOT(saver.FileName = 'Untitled Exercise') then
        begin
        SaveHistory;
        AssignFile(DatFile, saver.FileName);
        Rewrite(DatFile);
        for x := 1 to 10 do
                Write(DatFile, History[x]);
        CloseFile(DatFile);
        end;
end;

// Opens a file containing Pattern Data.
procedure Tfrmmain.OpenDataFile1Click(Sender: TObject);
var
        x : Byte;
        DatFile : File of TPatterns;
begin
        opener.Filter := 'DrumGen Data (.gdh)|*.gdh';
        opener.Execute;

        if NOT (opener.FileName = '') then
        begin
        AssignFile(DatFile, opener.FileName);
        Reset(DatFile);
        for x := 1 to 10 do
                Read(DatFile, History[x]);

        CloseFile(DatFile);

        opener.FileName := '';
        lblhist.caption:= '1';
        LoadHistory;
        GeneratePattern;
        end;
end;

// Saves the currently loaded pattern as an image.
procedure Tfrmmain.SaveImageNotation1Click(Sender: TObject);
var
        x, cX, aX, aY, cY : integer;
        ImgRect, PosRect : TRect;
        NewImage : TImage;
begin
        saver.DefaultExt := 'bmp';
        saver.Filter := 'Bitmap File (.bmp)|*.bmp';
        saver.FileName := 'Untitled Exercise';
        saver.execute;

        if NOT(saver.FileName = 'Untitled Exercise') then
        begin
                aX := ImgPat.Width div ImgNotes.Width;
                if (aX mod 2) = 0 then
                        aY := (aX div 2) * ImgNotes.Height
                        else
                        aY := ((aX div 2) + 1) * ImgNotes.Height;


                NewImage := TImage.Create(frmmain);
                NewImage.Height := aY;
                NewImage.Width := ImgNotes.Width;

                x := -1;
                cX := -1;
                cY := 0;
                if aX > 1 then
                begin
                NewImage.Width := ImgNotes.Width * 2;
                repeat
                        x := x + 1;
                        cX := cX + 1;
                        if cX >= 2 then
                                begin
                                cY := cY + 1;
                                cX := 0;
                                end;
                        PosRect := Rect((ImgNotes.Width * x),0,(ImgNotes.Width * (x + 1)),ImgNotes.Height);
                        ImgRect := Rect((ImgNotes.Width * cX),(ImgNotes.Height * cY),(ImgNotes.Width * (cX + 1)),(ImgNotes.Height * (cY + 1)));
                        NewImage.Canvas.CopyRect(ImgRect,ImgPat.Canvas,PosRect);
                until x > aX;
                end // End aX > 1 part
                else
                begin
                        ImgRect := Rect(0,0,ImgNotes.Width,ImgNotes.Height);
                        NewImage.Canvas.CopyRect(ImgRect,ImgPat.Canvas,ImgRect);
                end;

                NewImage.Picture.SaveToFile(saver.FileName);
                NewImage.Destroy;
        end;
end;

procedure Tfrmmain.btnremaccClick(Sender: TObject);
var
        x : byte;
begin
        for x := 1 to 4 do
        LimbPat[x].AccentPat := '-';

        imgnotes.Canvas.FillRect(Rect(0,0,imgnotes.Width,imgnotes.Height));
        drawcount(20,ImgPat);
        drawnotes(1,ImgPat);
        drawnotes(2,ImgPat);
        drawnotes(3,ImgPat);
        drawnotes(4,ImgPat);
        imgnotes.Canvas.Draw(0,0,ImgPat);
        ImgPat.Canvas.FillRect(Rect(0,0,imgpat.Width,imgpat.Height));
end;

// Clears the History array.
procedure Tfrmmain.btnclearhistClick(Sender: TObject);
var
        x : Byte;
begin
        if MessageDlg('This will clear all the stored patterns. Do you wish to continue?',mtWarning,[mbYes,mbNo],0)
        = mrYes then
        begin
        for x := 1 to 10 do
        History[x] := DefaultPattern;
        lblhist.caption := '1';
        end;
end;

// Resets the subdivision settings to defaults.
procedure Tfrmmain.btnressubClick(Sender: TObject);
var
        x : byte;
begin
        for x := 1 to 4 do
        begin
        LimbPat[x].NumSpread := 2;
        LimbPat[x].NumSubs := 2;
        LimbPat[x].SType := '2';
        LimbPat[x].SDiver := LimbPat[x].SNVal * (StrToInt(LimbPat[x].SType) / LimbPat[x].NumSpread);
        end;

        GeneratePattern;
end;

// Calling the functions to draw the patterns on
// the canvas.
procedure Tfrmmain.btnresnotevalClick(Sender: TObject);
var
        x : byte;
begin
        for x := 1 to 4 do
        begin
        LimbPat[x].SNVal := 1;
        LimbPat[x].SDiver := LimbPat[x].SNVal * (StrToInt(LimbPat[x].SType) / LimbPat[x].NumSpread);
        end;

        GeneratePattern;
end;

procedure Tfrmmain.pulserTimer(Sender: TObject);
var
        ShpPos : integer;
begin
        CountPos := CountPos + 1;
        if CountPos >= Counts then begin CountPos := 0; BarCount := BarCount + 1; end;
        if BarCount >= sedta.value then BarCount := 0;

        scrolltimer.Enabled := true;
       // if scrlbarimgnotes.Enabled = true then
      //  if scrlbarimgnotes.Position = scrlbarimgnotes.Max then scrlbarimgnotes.position := 0 else
      //  scrlbarimgnotes.Position := scrlbarimgnotes.Position + (scrlbarimgnotes.max div (counts));

        ShpPos := imgnotes.left + (MetroGrid.Left + (MetroGrid.CellWidth * ((Counts * BarCount) + CountPos))) - scrlbarimgnotes.position;
        shpbar.Left := ShpPos;

        if frmmetro.chksound.Checked = false then
        if frmmetro.chkmother.Checked = true then
               MetroPatternPulse else
        if CountPos = 0 then
        midiOutShortMsg(hMid,MidiMetro[1]) else
        midiOutShortMsg(hMid,MidiMetro[2]);
end;

procedure Tfrmmain.RandomRhythm1Click(Sender: TObject);
var
        x : byte;
begin
        Randomize;
        for x := 1 to 4 do
        Randomator(LimbPat[x].RhythmPat);
        GeneratePattern;
        PrevRandBtn := RandomRhythm1;
end;

procedure Tfrmmain.RandomAccents1Click(Sender: TObject);
var
        x : byte;
begin
        Randomize;
        for x := 1 to 4 do
        RandomatorA(LimbPat[x].AccentPat);
        GeneratePattern;
        PrevRandBtn := RandomAccents1;
end;

procedure Tfrmmain.RandomNoteValues1Click(Sender: TObject);

begin
        Randomize;
        RandomatorSDiv('N',1,InUseNotes);
        RandomatorSDiv('N',2,InUseNotes);
        RandomatorSDiv('N',3,InUseNotes);
        RandomatorSDiv('N',4,InUseNotes);
        GeneratePattern;
        PrevRandBtn := RandomNoteValues1;
end;

procedure Tfrmmain.RandomSubdivision1Click(Sender: TObject);
begin
        Randomize;
        RandomatorSDiv('S',1,InUseSub);
        RandomatorSDiv('S',2,InUseSub);
        RandomatorSDiv('S',3,InUseSub);
        RandomatorSDiv('S',4,InUseSub);
        OnNSBtnClick(Sender);
        GeneratePattern;
        PrevRandBtn := RandomSubdivision1;
end;

procedure Tfrmmain.ReversePattern1Click(Sender: TObject);
begin
        ErrorChecker(EdtSel.Text);
        EdtSel.Text := ReversePattern(EdtSel.Text);
        GeneratePattern;
end;

procedure Tfrmmain.AllPatterns1Click(Sender: TObject);
begin
        RhythmPatterns1.Click;
        AccentPatterns1.Click;
end;

procedure Tfrmmain.RhythmPatterns1Click(Sender: TObject);
var
        x : byte;
begin
        for x := 1 to 4 do
        LimbPat[x].RhythmPat := ReversePattern(LimbPat[x].RhythmPat);
        GeneratePattern;
end;

procedure Tfrmmain.AccentPatterns1Click(Sender: TObject);
var
        x : byte;
begin
        for x := 1 to 4 do
        LimbPat[x].AccentPat := ReversePattern(LimbPat[x].AccentPat);
        GeneratePattern;
end;

procedure Tfrmmain.InversePattern1Click(Sender: TObject);
begin
        if IRType = 'S' then
        EdtSel.Text := InvertPatternS(EdtSel.Text);

        if IRType = 'A' then
        EdtSel.Text := InvertPatternA(EdtSel.Text);

        GeneratePattern;
end;

procedure Tfrmmain.RandomPattern1Click(Sender: TObject);
begin
        if IRType = 'S' then
        begin
        Randomator(LimbPat[SelLimb].RhythmPat);
        edtrpat.Text := LimbPat[SelLimb].RhythmPat;
        end;

        if IRType = 'A' then
        begin
        RandomatorA(LimbPat[SelLimb].AccentPat);
        edtapat.Text := LimbPat[SelLimb].AccentPat;
        end;
        GeneratePattern;
end;

procedure Tfrmmain.RhythmPatterns2Click(Sender: TObject);
var
        x : byte;
begin
        for x := 1 to 4 do
        LimbPat[x].RhythmPat := InvertPatternS(LimbPat[x].RhythmPat);
        GeneratePattern;
end;

procedure Tfrmmain.AccentPatterns2Click(Sender: TObject);
var
        x : byte;
begin
        for x := 1 to 4 do
        LimbPat[x].AccentPat := InvertPatternA(LimbPat[x].AccentPat);
        GeneratePattern;
end;

procedure Tfrmmain.AllPatterns2Click(Sender: TObject);
begin
        RhythmPatterns2.Click;
        AccentPatterns2.Click;
end;

procedure Tfrmmain.RandomExercise1Click(Sender: TObject);
begin
        RandomRhythm1.Click;

        if frmrandopt.chkaccent.Checked = true then
                RandomAccents1.Click;

        RandomNoteValues1.Click;
        RandomSubdivision1.Click;
        PrevRandBtn := RandomExercise1;
end;

procedure Tfrmmain.MetronomeOptions1Click(Sender: TObject);
begin
        frmmetro.visible := true;
        frmmetro.bringtofront;
        frmmain.Enabled := false;
end;

procedure Tfrmmain.InitialiserTimer(Sender: TObject);
begin
        initialiser.Enabled := false;
        PrevRandBtn := RandomExercise1;
        frmabout.Show;
        frmmetro.cmbaccentChange(frmmetro.cmbaccent);
        frmmetro.cmbnormalChange(frmmetro.cmbnormal);
        frmmetro.cmbsubdivchange(frmmetro.cmbsubdiv);
        frmmidi.Close;
        frmrandopt.Close;
        Updater([Times]);
        GeneratePattern;
        frmmidi.ebtnrefreshmidiout.OnClick(Sender);
        frmmidi.ebtnrefreshmidiin.OnClick(Sender);
        if ViewReadMe = True then ReadMe1.Click;
        initialiser.Free;
end;

procedure Tfrmmain.sedtaChange(Sender: TObject);
begin
        Updater([Times,Patterns]);
end;

procedure Tfrmmain.sedtbChange(Sender: TObject);
begin
        Updater([Times,Patterns]);
end;

procedure Tfrmmain.VoicingOptions1Click(Sender: TObject);
begin
        frmkit.visible := true;
        frmkit.BringToFront;
        frmmain.Enabled := false;
end;

procedure Tfrmmain.RightHand1Click(Sender: TObject);
var
        Temp : string;
begin
        if IRType = 'S' then
        begin
                Temp := LimbPat[1].RhythmPat;
                LimbPat[1].RhythmPat := LimbPat[SelLimb].RhythmPat;
                LimbPat[SelLimb].RhythmPat := Temp;
        end;

        if IRType = 'A' then
        begin
                Temp := LimbPat[1].AccentPat;
                LimbPat[1].AccentPat := LimbPat[SelLimb].AccentPat;
                LimbPat[SelLimb].AccentPat := Temp;
        end;
        GeneratePattern;
end;

procedure Tfrmmain.LeftHand1Click(Sender: TObject);
var
        Temp : string;
begin
        if IRType = 'S' then
        begin
                Temp := LimbPat[2].RhythmPat;
                LimbPat[2].RhythmPat := LimbPat[SelLimb].RhythmPat;
                LimbPat[SelLimb].RhythmPat := Temp;
        end;

        if IRType = 'A' then
        begin
                Temp := LimbPat[2].AccentPat;
                LimbPat[2].AccentPat := LimbPat[SelLimb].AccentPat;
                LimbPat[SelLimb].AccentPat := Temp;
        end;
        GeneratePattern;
end;

procedure Tfrmmain.RightFoot1Click(Sender: TObject);
var
        Temp : string;
begin
        if IRType = 'S' then
        begin
                Temp := LimbPat[3].RhythmPat;
                LimbPat[3].RhythmPat := LimbPat[SelLimb].RhythmPat;
                LimbPat[SelLimb].RhythmPat := Temp;
        end;

        if IRType = 'A' then
        begin
                Temp := LimbPat[3].AccentPat;
                LimbPat[3].AccentPat := LimbPat[SelLimb].AccentPat;
                LimbPat[SelLimb].AccentPat := Temp;
        end;
        GeneratePattern;
end;

procedure Tfrmmain.LeftFoot1Click(Sender: TObject);
var
        Temp : string;
begin
        if IRType = 'S' then
        begin
                Temp := LimbPat[4].RhythmPat;
                LimbPat[4].RhythmPat := LimbPat[SelLimb].RhythmPat;
                LimbPat[SelLimb].RhythmPat := Temp;
        end;

        if IRType = 'A' then
        begin
                Temp := LimbPat[4].AccentPat;
                LimbPat[4].AccentPat := LimbPat[SelLimb].AccentPat;
                LimbPat[SelLimb].AccentPat := Temp;
        end;
        GeneratePattern;
end;

procedure Tfrmmain.RandomOptions1Click(Sender: TObject);
begin
        frmrandopt.visible := true;
        frmrandopt.BringToFront;
        frmmain.Enabled := false;
end;

procedure Tfrmmain.imgnotesMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
        if VGridDrawn = False then
        begin

        ImgTemp.Canvas.CopyRect(Rect(0,0,ImgNotes.Width,ImgNotes.Height),ImgNotes.Canvas,Rect(0,0,ImgNotes.Width,ImgNotes.Height));
        if frmprefs.chkrhact.checked = true then
                DrawGridLines(1,ImgTemp);
        if frmprefs.chklhact.checked = true then
                DrawGridLines(2,ImgTemp);
        if frmprefs.chkrfact.checked = true then
                DrawGridLines(3,ImgTemp);
        if frmprefs.chklfact.checked = true then
                DrawGridLines(4,ImgTemp);
        VGridDrawn := True;
        end;
end;

procedure Tfrmmain.imgnotesMouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
var
        VGridStat : TPoint;
begin
        if Button = mbMiddle then
        begin
               // grppatopts.Left := X;
                //grppatopts.Top := Y;
                grppatopts.Visible := True;
                VGridStat := DetermineCell(X,Y);
                SelLimb := VGridStat.X;

        if SelLimb <> 0 then
        LinkLimbRd[LinkedLimbs[SelLimb]].Checked := True;

        case VGridStat.X of
        0 : begin
                grppatopts.Visible := False;
        end;
        1 : begin
                grppatopts.Visible := True;
                grppatopts.Caption := 'Right Hand Pattern Options:';
                edtrpat.Text := LimbPat[1].RhythmPat;
                edtapat.Text := LimbPat[1].AccentPat;
                sedtsubdiv.Value := StrToInt(LimbPat[1].SType);
                sedtsubnotes.Value := LimbPat[1].NumSpread;
                if LimbPat[1].Mute = True then PanelUpdate(pnlmute,clYellow);
        end;
        2 : begin
                grppatopts.Visible := True;
                grppatopts.Caption := 'Left Hand Pattern Options:';
                edtrpat.Text := LimbPat[2].RhythmPat;
                edtapat.Text := LimbPat[2].AccentPat;
                sedtsubdiv.Value := StrToInt(LimbPat[2].SType);
                sedtsubnotes.Value := LimbPat[2].NumSpread;
                if LimbPat[2].Mute = True then PanelUpdate(pnlmute,clYellow);
        end;
        3 : begin
                grppatopts.Visible := True;
                grppatopts.Caption := 'Right Foot Pattern Options:';
                edtrpat.Text := LimbPat[3].RhythmPat;
                edtapat.Text := LimbPat[3].AccentPat;
                sedtsubdiv.Value := StrToInt(LimbPat[3].SType);
                sedtsubnotes.Value := LimbPat[3].NumSpread;
                if LimbPat[3].Mute = True then PanelUpdate(pnlmute,clYellow);
        end;
        4 : begin
                grppatopts.Visible := True;
                grppatopts.Caption := 'Left Foot Pattern Options:';
                edtrpat.Text := LimbPat[4].RhythmPat;
                edtapat.Text := LimbPat[4].AccentPat;
                sedtsubdiv.Value := StrToInt(LimbPat[4].SType);
                sedtsubnotes.Value := LimbPat[4].NumSpread;
                if LimbPat[4].Mute = True then PanelUpdate(pnlmute,clYellow);
        end;
        end;
        end;

        if MIDIOnNow = false then
        if UpdateMetroSliderPos(X,Y) = False then
        begin
        if Button = mbLeft then
        begin
        VGridStat := DetermineCell(X,Y);
        if VGridStat.X > 0 then
        if VGridStat.Y > 0 then
        begin
                UpdatePattern(VGridStat.X,VGridStat.Y,LimbPat[VGridStat.X].RhythmPat,LimbPat[VGridStat.X].AccentPat);

                imgnotes.Canvas.FillRect(Rect(0,0,imgnotes.Width,imgnotes.Height));
                Updater([Patterns]);

                DrawGridLines(1,ImgTemp);
                DrawGridLines(2,ImgTemp);
                DrawGridLines(3,ImgTemp);
                DrawGridLines(4,ImgTemp);
        end;
        end;
        end; // End if UpdateMetroSlider = False
end;

procedure Tfrmmain.FormMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
        DestR, SourceR : TRect;
begin
        If VGridDrawn = True then
        begin
        DestR := Rect(0,0,ImgNotes.Width,ImgNotes.Height);
        SourceR := Rect(scrlbarimgnotes.Position,0,(ImgNotes.Width + scrlbarimgnotes.Position),imgnotes.Height);
        ImgNotes.Canvas.CopyRect(DestR,ImgPat.Canvas,SourceR);
        VGridDrawn := False;
        end;
end;

procedure Tfrmmain.DrawNote1Click(Sender: TObject);
begin
        DrawNote1.Checked := True;
end;

procedure Tfrmmain.AccentNote1Click(Sender: TObject);
begin
        AccentNote1.Checked := True;
end;

procedure Tfrmmain.FormClose(Sender: TObject; var Action: TCloseAction);
begin
        midiOutClose(hMid);
end;

procedure Tfrmmain.MIDIOptions1Click(Sender: TObject);
begin
        frmmidi.Visible := true;
        frmmidi.BringToFront;
        frmmain.Enabled := false;
end;

procedure Tfrmmain.nt1Click(Sender: TObject);
begin
        VGridNoteChar := nt1.caption[2];
end;

procedure Tfrmmain.nt2Click(Sender: TObject);
begin
        VGridNoteChar := nt2.caption[2];
end;

procedure Tfrmmain.nt3Click(Sender: TObject);
begin
        VGridNoteChar := nt3.caption[2];
end;

procedure Tfrmmain.nt4Click(Sender: TObject);
begin
        VGridNoteChar := nt4.caption[2];
end;

procedure Tfrmmain.nt5Click(Sender: TObject);
begin
        VGridNoteChar := nt5.caption[2];
end;

procedure Tfrmmain.nt6Click(Sender: TObject);
begin
        VGridNoteChar := nt6.caption[2];
end;

procedure Tfrmmain.nt7Click(Sender: TObject);
begin
        VGridNoteChar := nt7.caption[2];
end;

procedure Tfrmmain.nt8Click(Sender: TObject);
begin
        VGridNoteChar := nt8.caption[2];
end;

procedure Tfrmmain.nt9Click(Sender: TObject);
begin
        VGridNoteChar := nt9.caption[2];
end;

procedure Tfrmmain.nt10Click(Sender: TObject);
begin
        VGridNoteChar := nt10.caption[2];
end;

procedure Tfrmmain.btncommentClick(Sender: TObject);
begin
        frmcomment.visible := true;
        frmcomment.BringToFront;
        frmmain.Enabled := false;
end;

procedure Tfrmmain.GeneralPreferences1Click(Sender: TObject);
begin
        frmprefs.visible := true;
        frmmain.Enabled := false;
end;

procedure Tfrmmain.RandomNoteValue1Click(Sender: TObject);
begin
        RandomatorSDiv('N',SelLimb,[All]);
        Updater([Patterns]);
end;

procedure Tfrmmain.RandomSubdivision2Click(Sender: TObject);
begin
        RandomatorSDiv('S',SelLimb,[All]);
        sedtsubdiv.value := Trunc(LimbPat[SelLimb].NumSubs);
        Updater([Patterns]);
end;

procedure Tfrmmain.StickingPatterns1Click(Sender: TObject);
begin
        frmsticking.visible := true;
        frmmain.Enabled := false;
end;

procedure Tfrmmain.SaveAsMIDI1Click(Sender: TObject);
begin
        saver.DefaultExt := 'mid';
        saver.Filter := 'MIDI File Format 0 (.mid)|*.mid';
        saver.FileName := 'Untitled Exercise';
        saver.execute;

        if NOT(saver.filename = 'Untitled Exercise') then
                MakeMIDIFile;
end;

procedure Tfrmmain.scrlbarimgnotesChange(Sender: TObject);
var
        DestR, SourceR : TRect;
begin
        DestR := Rect(0,0,ImgNotes.Width,ImgNotes.Height);
        SourceR := Rect(scrlbarimgnotes.Position,0,(ImgNotes.Width + scrlbarimgnotes.Position),imgnotes.Height);
        ImgNotes.Canvas.CopyRect(DestR,ImgPat.Canvas,SourceR);
        VGridDrawn := False;
end;

procedure Tfrmmain.PlayAlongKit1Click(Sender: TObject);
begin
        frmplayalong.Free;
        Application.CreateForm(Tfrmplayalong, frmplayalong);
        frmplayalong.Show;
end;

procedure Tfrmmain.Print1Click(Sender: TObject);
var
        TPrintImage : TImage;
        x, cX, aX, aY, cY : integer;
        ImgRect, PosRect : TRect;
begin
        if printdialog.Execute = true then
        begin
                aX := ImgPat.Width div ImgNotes.Width;
                if (aX mod 2) = 0 then
                        aY := (aX div 2) * ImgNotes.Height
                        else
                        aY := ((aX div 2) + 1) * ImgNotes.Height;

                TPrintImage := TImage.Create(frmmain);
                TPrintImage.Height := aY;
                TPrintImage.Width := ImgNotes.Width;

                x := -1;
                cX := -1;
                cY := 0;
                if aX > 1 then
                begin
                TPrintImage.Width := ImgNotes.Width * 2;
                repeat
                        x := x + 1;
                        cX := cX + 1;
                        if cX >= 2 then
                                begin
                                cY := cY + 1;
                                cX := 0;
                                end;
                        PosRect := Rect((ImgNotes.Width * x),0,(ImgNotes.Width * (x + 1)),ImgNotes.Height);
                        ImgRect := Rect((ImgNotes.Width * cX),(ImgNotes.Height * cY),(ImgNotes.Width * (cX + 1)),(ImgNotes.Height * (cY + 1)));
                        TPrintImage.Canvas.CopyRect(ImgRect,ImgPat.Canvas,PosRect);
                until x > aX;
                end // End aX > 1 part
                else
                begin
                        ImgRect := Rect(0,0,ImgNotes.Width,ImgNotes.Height);
                        TPrintImage.Canvas.CopyRect(ImgRect,ImgPat.Canvas,ImgRect);
                end;

        Printer.BeginDoc;
        Printer.Canvas.CopyRect(ImgRect,TPrintImage.Canvas,ImgRect);
        Printer.EndDoc;

        TPrintImage.Destroy;
        end; // End if printdialog.execute = true
end;

procedure Tfrmmain.btnhistprevClick(Sender: TObject);
begin
        if lblhist.Caption <> '1' then
        begin
        frmdevcntrl.btnmidistop.Click;
        SaveHistory;
        lblhist.caption := IntToStr(StrToInt(lblhist.caption) - 1);
        LoadHistory;
        VGridDrawn := false;
        Updater([Patterns]);
        end;
end;

procedure Tfrmmain.btnhistnextClick(Sender: TObject);
begin
        if lblhist.Caption <> '10' then
        begin
        frmdevcntrl.btnmidistop.Click;
        SaveHistory;
        lblhist.caption := IntToStr(StrToInt(lblhist.caption) + 1);
        LoadHistory;
        VGridDrawn := false;
        Updater([Patterns]);
        end;
end;

procedure Tfrmmain.FormCreate(Sender: TObject);
var
        x : Integer;
begin
        if regcode.CheckRegistered = false then
        MessageDlg('Program not registered yet! You have ' + inttostr(regcode.DaysLeft) + ' days left to register!',mtInformation,[mbOk],0);

        if regcode.CheckExpired = true then
        begin
        MessageDlg('Registration code has expired! Beta Version Automatically Resets.',mtInformation,[mbOk],0);
        regcode.SetUnregistered;
        end;

        ViewReadMe := False;
        if
        MessageDlg('Welcome to DrumGen BETA! Please be sure to read the ReadMe file from the "Help" menu for details of the program. Would you like to do this now?',mtInformation,[mbYes,mbNo],0)
        = mrYes then ViewReadMe := True;

        statbar.Panels.Items[1].Text := 'Created by Stephan Pieterse';

        frmmain.ChangeScale((Screen.Height + Screen.Width),(1024 + 768));
        HRat := Screen.Height / 768;
        WRat := Screen.Width / 1024;
        Randomize;

        StartPos := 1;
        shpbar.Height := imgnotes.Height;
        shpbar.Top := imgnotes.Top;
        shpbar.Width := 1;
        CountPos := 0;
        BarCount := 0;

        metrox := 2;
        metroy := 1;
        metrosy := 1;
        mpatcpos := 1;
        time := 1;

        MidiTimer[1] := 0;
        MidiTimer[2] := 0;
        MidiTimer[3] := 0;
        MidiTimer[4] := 0;

        DefaultPattern.AVal := 1;
        DefaultPattern.BVal := 4;
        DefaultPattern.SNValRH := 1;
        DefaultPattern.STypeRH := '2';
        DefaultPattern.SNValLH := 1;
        DefaultPattern.STypeLH := '2';
        DefaultPattern.SNValRF := 1;
        DefaultPattern.STypeRF := '2';
        DefaultPattern.SNValLF := 1;
        DefaultPattern.STypeLF := '2';
        DefaultPattern.RHS := '-';
        DefaultPattern.LHS := '-';
        DefaultPattern.RFS := '-';
        DefaultPattern.LFS := '-';
        DefaultPattern.RHA := '-';
        DefaultPattern.LHA := '-';
        DefaultPattern.RFA := '-';
        DefaultPattern.LFA := '-';
       // for x := 1 to 1000 do
            //    DefaultPattern.Comment[x] := ' ';
        DefaultPattern.Comment := '';

        VGridNoteChar := 'x';

        for x := 1 to 10 do
        begin
                History[x] := DefaultPattern;

                Symbols[x] := TBitmap.Create;
                Symbols[x].Height := 16;
                Symbols[x].Width := 16;
                imglistsymbols.Draw(Symbols[x].Canvas,0,0,(x-1),true);

                MidiCompCmd[x,1] := 0;
                MidiCompCmd[x,2] := 0;
        end;

        for x := 1 to 6 do
        begin
                Rests[x] := TBitmap.Create;
                Rests[x].Height := 16;
                Rests[x].Width := 16;
                imglistrests.Draw(Rests[x].Canvas,0,0,(x-1),true);
        end;

        for x := 1 to 4 do
        begin
                LimbPat[x].RhythmPat := '-';
                LimbPat[x].AccentPat := '-';
                LimbPat[x].Active := True;
                LimbPat[x].Mute := False;
                LimbPat[x].NumSubs := 1;
                LimbPat[x].NumSpread := 2;
                LimbPat[x].SType := '2';
                LimbPat[x].SNVal := 1;
                LimbPat[x].SDiver := LimbPat[x].SNVal * (StrToInt(LimbPat[x].SType) / LimbPat[x].NumSpread);
        end;

        LinkLimbRd[0] := rdlinknone;
        LinkLimbRd[1] := rdlinkrh;
        LinkLimbRd[2] := rdlinklh;
        LinkLimbRd[3] := rdlinkrf;
        LinkLimbRd[4] := rdlinklf;

        MidiMetro[1] := 0;
        MidiMetro[2] := 0;
        MidiMetro[3] := 0;

        VGridDrawn := False;
        ImgPat := TBitmap.Create;
        ImgPat.Height := imgnotes.Height;
        ImgPat.Width := imgnotes.Width;
        ImgTemp := TBitmap.Create;
        ImgTemp.Height := imgnotes.Height;
        ImgTemp.Width := imgnotes.Width;
        ImgPat.Canvas.CopyMode := cmSrcCopy;
        ImgTemp.Canvas.CopyMode := cmSrcCopy;
        ImgNotes.Canvas.CopyMode := cmSrcCopy;
        ImgNotes.Enabled := True;
        
        frmmain.width := (imgnotes.Left + imgnotes.Width + 16);

        DrawImageEdges;

        initialiser.Enabled := true;
end;

procedure Tfrmmain.btnclearpatrepClick(Sender: TObject);
begin
        if MessageDlg('This will clear all the patterns currently in the Pattern Repository. Do you wish to continue?',mtWarning,[mbYes,mbNo],0)
        = mrYes then lstpatrep.Clear;
end;

procedure Tfrmmain.AddToRepository1Click(Sender: TObject);
begin
        if IRType = 'S' then
        ErrorCorrector(LimbPat[SelLimb].RhythmPat);
        if IRType = 'A' then
        ErrorCorrectorA(LimbPat[SelLimb].AccentPat);
        IntoRepository(EdtSel.Text, IRType, True)
end;

procedure Tfrmmain.Rhythm1Click(Sender: TObject);
begin
        FromRepository(lstpatrep.Items.Strings[lstpatrep.itemindex],'R',LimbPat[1].RhythmPat);
end;

procedure Tfrmmain.Rhythm2Click(Sender: TObject);
begin
        FromRepository(lstpatrep.Items.Strings[lstpatrep.itemindex],'R',LimbPat[2].RhythmPat);
end;

procedure Tfrmmain.Rhythm3Click(Sender: TObject);
begin
        FromRepository(lstpatrep.Items.Strings[lstpatrep.itemindex],'R',LimbPat[3].RhythmPat);
end;

procedure Tfrmmain.Rhythm4Click(Sender: TObject);
begin
        FromRepository(lstpatrep.Items.Strings[lstpatrep.itemindex],'R',LimbPat[4].RhythmPat);
end;

procedure Tfrmmain.Accent1Click(Sender: TObject);
begin
        FromRepository(lstpatrep.Items.Strings[lstpatrep.itemindex],'A',LimbPat[1].AccentPat);
end;

procedure Tfrmmain.Accent2Click(Sender: TObject);
begin
        FromRepository(lstpatrep.Items.Strings[lstpatrep.itemindex],'A',LimbPat[2].AccentPat);
end;

procedure Tfrmmain.Accent4Click(Sender: TObject);
begin
        FromRepository(lstpatrep.Items.Strings[lstpatrep.itemindex],'A',LimbPat[4].AccentPat);
end;

procedure Tfrmmain.Accent3Click(Sender: TObject);
begin
        FromRepository(lstpatrep.Items.Strings[lstpatrep.itemindex],'A',LimbPat[3].AccentPat);
end;

procedure Tfrmmain.SavePatternRepository1Click(Sender: TObject);
var
        x : integer;
        TempStr : String[255];
        FileSNew : TFileStream;
begin
        saver.DefaultExt := 'gdpr';
        saver.Filter := 'DrumGen Pattern Repository (.gdpr)|*.gdpr';
        saver.FileName := 'Untitled Patterns';
        saver.execute;

        if NOT(saver.FileName = 'Untitled Patterns') then
        begin
        FileSNew := TFileStream.Create(saver.FileName,fmCreate);
        for x := 0 to (lstpatrep.items.count - 1) do
        begin
                TempStr := lstpatrep.Items[x];
                FileSNew.WriteBuffer(TempStr,255);
        end;
        FileSNew.Free;
        end;

end;

procedure Tfrmmain.OpenPatternRepository1Click(Sender: TObject);
var
        TempStr : String[255];
        FileSNew : TFileStream;
begin
        opener.Filter := 'DrumGen Pattern Repository (.gdpr)|*.gdpr';
        opener.Execute;

        if NOT (opener.FileName = '') then
        if MessageDlg('Click ''Yes'' to add the file to the current repository, and ''No'' to load the file into a cleared repository.',mtConfirmation,[mbYes,mbNo],0)
        = mrYes then
        begin
        FileSNew := TFileStream.Create(opener.FileName,fmOpenRead);
        repeat
                FileSNew.ReadBuffer(TempStr,255);
                IntoRepository(TempStr, 'S', False)
        until FileSNew.Position = FileSNew.Size;
        opener.FileName := '';
        FileSNew.Free;
        end
        else
        begin
        lstpatrep.Clear;

        FileSNew := TFileStream.Create(opener.FileName,fmOpenRead);
        repeat
                FileSNew.ReadBuffer(TempStr,255);
                lstpatrep.Items.Add(TempStr);
        until FileSNew.Position = FileSNew.Size;
        opener.FileName := '';
        FileSNew.Free;
        end; // End if MessageDlg
end;

procedure Tfrmmain.DeletePattern1Click(Sender: TObject);
begin
        lstpatrep.Items.Delete(lstpatrep.ItemIndex);
end;

procedure Tfrmmain.popuppatrepPopup(Sender: TObject);
var
        Clickitem : integer;
        coord : TPoint;
begin
        coord := Point((popuppatrep.PopupPoint.x - lstpatrep.left - frmmain.Left - (frmmain.Width - frmmain.ClientWidth)),(popuppatrep.PopupPoint.y - lstpatrep.top - frmmain.top - (frmmain.Height -frmmain.ClientHeight)));
        Clickitem := lstpatrep.ItemAtPos(coord,true);
        lstpatrep.itemindex := Clickitem;
        if lstpatrep.ItemIndex = -1 then
        begin
        ApplyPatternTo1.Enabled := false;
        DeletePattern1.Enabled := false;
        end
        else
        begin
        ApplyPatternTo1.Enabled := true;
        DeletePattern1.Enabled := true;
        end;
end;

procedure Tfrmmain.DeviceControls1Click(Sender: TObject);
begin
        DeviceControls1.Checked := NOT(DeviceControls1.Checked);
        frmdevcntrl.Visible := DeviceControls1.Checked;
end;

procedure Tfrmmain.Register1Click(Sender: TObject);
begin
        Frmreg.Visible := true;
        Frmreg.BringToFront;
        frmmain.Enabled := false;
end;

procedure Tfrmmain.RhythmTrainer1Click(Sender: TObject);
begin
        Frmrhythmtrain.Visible := true;
        Frmrhythmtrain.BringToFront;
        frmmain.Enabled := false;
end;

procedure Tfrmmain.ReadMe1Click(Sender: TObject);
var
        ReadMeF : TResourceStream;
begin
        ReadMeF := TResourceStream.Create(hInstance,'README','RT_RCDATA');
        ReadMeF.SaveToFile(ExtractFilePath(Application.ExeName) + 'Readmetemp.pdf');
        ShellExecute(hInstance,'open','Readmetemp.pdf',nil,Pointer(ExtractFilePath(Application.ExeName)),0);
        ReadMeF.Free;
        Sleep(3000);
        DeleteFile(ExtractFilePath(Application.ExeName) + 'Readmetemp.pdf');
end;

{

----- BACKUP CODE SNIPPET -----

procedure Tfrmmain.EditPattern1Click(Sender: TObject);
var
        PopupPos, ResultPos : TPoint;
begin
        btnaccept.Enabled := true;
        btnwhole.Enabled := true;
        btnhalf.Enabled := true;
        btnquarter.Enabled := true;
        btneight.Enabled := true;
        btnsixteen.Enabled := true;
        btn32.Enabled := true;
        sedtsubnotes.Enabled := true;
        sedtsubdiv.Enabled := true;
        pnlmute.Enabled := true;
        edtrpat.Enabled := true;
        edtapat.enabled := true;

        PopupPos.X := popupgrid.PopupPoint.X - imgnotes.Left - frmmain.Left - (frmmain.width - frmmain.ClientWidth);
        PopupPos.Y := popupgrid.PopupPoint.Y - imgnotes.top - frmmain.top - (frmmain.Height - frmmain.Clientheight);
        ResultPos := DetermineCell(popuppos.X,popuppos.y);
        case ResultPos.X of
        0 : begin
                grppatopts.Caption := 'NO LIMB SELECTED';
                btnaccept.Enabled := false;
                btnwhole.Enabled := false;
                btnhalf.Enabled := false;
                btnquarter.Enabled := false;
                btneight.Enabled := false;
                btnsixteen.Enabled := false;
                btn32.Enabled := false;
                sedtsubnotes.Enabled := false;
                sedtsubdiv.Enabled := false;
                pnlmute.enabled := false;
                edtrpat.Enabled := false;
                edtapat.enabled := false;
        end;
        1 : begin
                grppatopts.Caption := 'Right Hand Pattern Options:';
                edtrpat.Text := LimbPat[1].RhythmPat;
                edtapat.Text := LimbPat[1].AccentPat;
                sedtsubdiv.Value := StrToInt(LimbPat[1].SType);
                sedtsubnotes.Value := LimbPat[1].NumSpread;
                if LimbPat[1].Mute = True then PanelUpdate(pnlmute,clYellow);
        end;
        2 : begin
                grppatopts.Caption := 'Left Hand Pattern Options:';
                edtrpat.Text := LimbPat[2].RhythmPat;
                edtapat.Text := LimbPat[2].AccentPat;
                sedtsubdiv.Value := StrToInt(LimbPat[2].SType);
                sedtsubnotes.Value := LimbPat[2].NumSpread;
                if LimbPat[2].Mute = True then PanelUpdate(pnlmute,clYellow);
        end;
        3 : begin
                grppatopts.Caption := 'Right Foot Pattern Options:';
                edtrpat.Text := LimbPat[3].RhythmPat;
                edtapat.Text := LimbPat[3].AccentPat;
                sedtsubdiv.Value := StrToInt(LimbPat[3].SType);
                sedtsubnotes.Value := LimbPat[3].NumSpread;
                if LimbPat[3].Mute = True then PanelUpdate(pnlmute,clYellow);
        end;
        4 : begin
                grppatopts.Caption := 'Left Foot Pattern Options:';
                edtrpat.Text := LimbPat[4].RhythmPat;
                edtapat.Text := LimbPat[4].AccentPat;
                sedtsubdiv.Value := StrToInt(LimbPat[4].SType);
                sedtsubnotes.Value := LimbPat[4].NumSpread;
                if LimbPat[4].Mute = True then PanelUpdate(pnlmute,clYellow);
        end;
        end;
        grppatopts.Visible := true;
        imgnotes.Enabled := false;
        SelLimb := ResultPos.X;
        if SelLimb <> 0 then
        LinkLimbRd[LinkedLimbs[SelLimb]].Checked := True;
end;        }

procedure Tfrmmain.btnacceptClick(Sender: TObject);
var
        x : byte;
begin
        LimbPat[SelLimb].RhythmPat := edtrpat.text;
        LimbPat[SelLimb].AccentPat := edtapat.text;
        if pnlmute.Color = clYellow then
        LimbPat[SelLimb].Mute := True else LimbPat[SelLimb].Mute := false;

        for x := 1 to 4 do
        begin
        LimbPat[x].SDiver := LimbPat[x].SNVal * (StrToInt(LimbPat[x].SType) / LimbPat[x].NumSpread);
        LinkLimbRd[x].Checked := False;
        end;

        Updater([Patterns]);

        grppatopts.Visible := false;
        imgnotes.Enabled := true;
        if pnlmute.Color = clYellow then PanelUpdate(pnlmute,clYellow);
end;

procedure Tfrmmain.pnlmuteClick(Sender: TObject);
begin
        PanelUpdate(pnlmute,clYellow);
end;

procedure Tfrmmain.btnquarterClick(Sender: TObject);
begin
        LimbPat[SelLimb].SNVal := 1;
        OnNSBtnClick(Sender);
end;

procedure Tfrmmain.btnhalfClick(Sender: TObject);
begin
        LimbPat[SelLimb].SNVal := 1/2;
        OnNSBtnClick(Sender);
end;

procedure Tfrmmain.btnwholeClick(Sender: TObject);
begin
        LimbPat[SelLimb].SNVal := 1/4;
        OnNSBtnClick(Sender);
end;

procedure Tfrmmain.btneightClick(Sender: TObject);
begin
        LimbPat[SelLimb].SNVal := 2;
        OnNSBtnClick(Sender);
end;

procedure Tfrmmain.btnsixteenClick(Sender: TObject);
begin
        LimbPat[SelLimb].SNVal := 4;
        OnNSBtnClick(Sender);
end;

procedure Tfrmmain.btn32Click(Sender: TObject);
begin
        LimbPat[SelLimb].SNVal := 8;
        OnNSBtnClick(Sender);
end;

procedure Tfrmmain.sedtsubdivChange(Sender: TObject);
begin
        LimbPat[SelLimb].SType := inttostr(sedtsubdiv.Value)[1];
        LimbPat[SelLimb].NumSubs := (sedtsubdiv.Value);
        OnNSBtnClick(Sender);
end;

procedure Tfrmmain.sedtsubnotesChange(Sender: TObject);
begin
        LimbPat[SelLimb].NumSpread := sedtsubnotes.Value;
        OnNSBtnClick(Sender);
end;

procedure Tfrmmain.edtapatMouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
        EdtSel := edtapat;
        IRType := 'A'
end;

procedure Tfrmmain.edtrpatMouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
        EdtSel := edtrpat;
        IRType := 'S';
end;

procedure Tfrmmain.rdlinklhClick(Sender: TObject);
begin
        if LinkedLimbs[SelLimb] <> 0 then
                LinkedLimbs[LinkedLimbs[SelLimb]] := 0;
        LinkedLimbs[SelLimb] := 2;
        LinkLimbUpdate;
end;

procedure Tfrmmain.rdlinkrhClick(Sender: TObject);
begin
        if LinkedLimbs[SelLimb] <> 0 then
                LinkedLimbs[LinkedLimbs[SelLimb]] := 0;
        LinkedLimbs[SelLimb] := 1;
        LinkLimbUpdate;
end;

procedure Tfrmmain.rdlinklfClick(Sender: TObject);
begin
        if LinkedLimbs[SelLimb] <> 0 then
                LinkedLimbs[LinkedLimbs[SelLimb]] := 0;
        LinkedLimbs[SelLimb] := 4;
        LinkLimbUpdate;
end;

procedure Tfrmmain.rdlinkrfClick(Sender: TObject);
begin
        if LinkedLimbs[SelLimb] <> 0 then
                LinkedLimbs[LinkedLimbs[SelLimb]] := 0;
        LinkedLimbs[SelLimb] := 3;
        LinkLimbUpdate;
end;

procedure Tfrmmain.rdlinknoneClick(Sender: TObject);
begin
        if LinkedLimbs[SelLimb] <> 0 then
                LinkedLimbs[LinkedLimbs[SelLimb]] := 0;
        LinkedLimbs[SelLimb] := 0;
        LinkLimbUpdate;
end;

procedure Tfrmmain.LinkLimbUpdate;
begin
        if LinkedLimbs[SelLimb] <> 0 then
        begin
        LimbPat[LinkedLimbs[SelLimb]].SNVal := LimbPat[SelLimb].SNVal;
        LimbPat[LinkedLimbs[SelLimb]].SType := LimbPat[SelLimb].SType;
        LimbPat[LinkedLimbs[SelLimb]].NumSpread := LimbPat[SelLimb].NumSpread;
        LinkedLimbs[LinkedLimbs[SelLimb]] := SelLimb;
        end;
end;

procedure Tfrmmain.scrolltimerTimer(Sender: TObject);
begin
        if scrlbarimgnotes.Position >= scrlbarimgnotes.Max then
        scrlbarimgnotes.position := 0;

        scrlbarimgnotes.Position := scrlbarimgnotes.position + 1;
        shpbar.Left := shpbar.left - 1;
end;

procedure Tfrmmain.FormDeactivate(Sender: TObject);
begin
        if (frmdevcntrl.Active = false) and (frmplayalong.Active = false) then
        begin
        DevControlPrevState := DeviceControls1.Checked;
        if DeviceControls1.Checked = True then
                DeviceControls1.Click;
        end;
end;

procedure Tfrmmain.FormActivate(Sender: TObject);
begin
        if (DevControlPrevState = True) and (DeviceControls1.Checked = False)then
                DeviceControls1.Click;
end;

procedure Tfrmmain.btnoptokClick(Sender: TObject);
begin
        grpgenopt.Visible := false;
        updater([Times,Patterns]);
end;

procedure Tfrmmain.Options2Click(Sender: TObject);
begin
        grpgenopt.Visible := true;
end;

procedure Tfrmmain.ApplyVoicing1Click(Sender: TObject);
var
        TempStr : String;
begin
        TempStr := edtrpat.Text;
        frmkit.ApplyVoicings(SelLimb,TempStr);
        edtrpat.Text := TempStr;
end;

procedure Tfrmmain.popuppatPopup(Sender: TObject);
begin
        if popuppat.popupcomponent = edtapat then ApplyVoicing1.Enabled := false;
        if popuppat.popupcomponent = edtrpat then ApplyVoicing1.Enabled := true;
end;

procedure Tfrmmain.udrpatClick(Sender: TObject; Button: TUDBtnType);
begin
        if Button = btPrev then
           edtrpat.text := PatternShift(edtrpat.text,'L');
        if Button = btNext then
           edtrpat.Text := PatternShift(edtrpat.text,'R');
end;

procedure Tfrmmain.udapatClick(Sender: TObject; Button: TUDBtnType);
begin
        if Button = btPrev then
           edtapat.text := PatternShift(edtapat.text,'L');
        if Button = btNext then
           edtapat.Text := PatternShift(edtapat.text,'R');
end;

procedure Tfrmmain.tbtnrandClick(Sender: TObject);
begin
        PrevRandBtn.Click;
end;

end.
